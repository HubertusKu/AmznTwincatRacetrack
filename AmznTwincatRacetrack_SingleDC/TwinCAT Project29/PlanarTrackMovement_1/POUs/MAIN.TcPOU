<?xml version="1.0" encoding="utf-8"?>
<TcPlcObject Version="1.1.0.1">
  <POU Name="MAIN" Id="{66ade15a-bef8-4e71-a124-c2e5978c50eb}" SpecialFunc="None">
    <Declaration><![CDATA[PROGRAM MAIN
VAR
	bAllDone					: BOOL;
	bStopSequence				: BOOL;
	                    		
	nCase 						: INT;
	nMoveState					: ARRAY[1..nNumMaxMovers] OF INT;
	                    		
	aDynamics					: ARRAY[1..nNumMaxMovers] OF Tc3_Physics.DynamicConstraint_PathXY;
	aMoveOnTrackOptions 		: ARRAY[1..20] OF Tc3_Mc3PlanarMotion.ST_MoveOnTrackOptions;
	                    		
	fbXtsEnvironment			: Tc3_XTS_Utility.FB_TcIoXtsEnvironment;
	                    		
	nForCounter					: UDINT;
	M,N,T,Tr					: UDINT;
	dynamics					: INT;
	                    		
// Magnet
	MagnetValue AT%Q*			: INT;
	bMagnetOn 					: BOOL;	
	stPositionInfo				: Tc3_XTS_Utility.ST_PositionInfo;
	stSwitchConfig				: ST_SwitchConfig;
	
//Configuration Values
	stMoverConfig				: ST_MoverConfig;
	stTrackConfig				: ST_TrackConfig;
		
	pwm: FB_PWM;
	
	IsMoverCommandedInShortcut	: BOOL;
	IsMoverInBlockingArea		: BOOL;
	nActStopPos					: UINT := 1;
	Fp_error 					: R_Trig;
	Switch 						: BOOL;
	WithoutSwitch 				: BOOL := TRUE;
	SwitchOnly					: BOOL;
	
	MoverStop 	AT%I* :BOOL;
	MoverStopDone AT%Q*		: BOOL;
	Info 		AT%Q*: BOOL;
	Operating	AT%Q*: BOOL;
	Process		AT%Q*: BOOL;
	Fault		AT%Q*: BOOL;
	Emergency	AT%Q*: BOOL;
	
	Voltage1 AT%I*: UDINT;
	Voltage2 AT%I*: UDINT;
	
	
	TcRestart : TC_Restart;
	Restart : BOOL;
	busy : BOOL;
	fp_start : R_Trig;
	bStartSequence: BOOL;
	
	FP_Counter : r_trig;
	Switchcounter : DINT;
	SwitchCurrent: INT :=12; 
	test : LREAL;
	Horntimer : tp; 
	R_trigHorn : R_trig;
	
	TestPowerMat : BOOL;
	StopTime : TIME := T#8S;
	StopTimer :ARRAY[1..nNumMaxMovers] OF Tc2_Standard.TON;
	StartTimer :ARRAY[1..nNumMaxMovers] OF BOOL;
	
	
	MoverPos :ARRAY[1..nNumMaxMovers] OF Tc3_Physics.PositionXYC;
	ArcLength :ARRAY[1..nNumMaxMovers] OF LREAL;
	TrackPos :ARRAY[1..nNumMaxMovers] OF ARRAY[1..nNumMaxTracks] OF Tc3_Physics.PositionXYC;
	
END_VAR
]]></Declaration>
    <Implementation>
      <ST><![CDATA[fbXtsEnvironment.Init(TRUE);

Emergency :=  MoverStop;

Operating := NOT  MoverStop;
R_trigHorn(clk := Voltage1> 10000 OR Voltage2 >10000);
Horntimer(in:= ( R_trigHorn.Q ) , PT:= T#2S,Q=> info);

IF nCASE > 90 THEN
	Process := TRUE;
ELSE 
	Process := FALSE;	
END_IF

IF NOT fbXtsEnvironment.P_IsInitialized THEN
	RETURN;
END_IF

IF NOT MoverStop AND NOT MoverStopDone THEN
	FOR nForCounter:=1 TO nNumMovers DO
		aDynamics[nForCounter].SetValuesVADJ(V := stMoverConfig.MaxVelo, A := stMoverConfig.MaxAccel, D := stMoverConfig.MaxDecel, J := stMoverConfig.MaxJerk);
		nCase := 140;
		//fbPlanarMover[nForCounter].McPlanarMover.Halt(MoverFeedback[nForCounter], aDynamics[nForCounter]);
	END_FOR		
	MoverStopDone := TRUE;
ELSIF 	MoverStop THEN
	MoverStopDone := FALSE;
END_IF


	TcRestart(
	NETID:= '', 
	RESTART:= Restart, 
	TMOUT:=T#5S , 
	BUSY=>busy , 
	ERR=> , 
	ERRID=> );


fp_start(clk:=bStartSequence);
IF fp_start.Q THEN
	nCase := 10;
	bStartSequence := FALSE;
END_IF


IsMoverCommandedInShortcut := FALSE;
IsMoverInBlockingArea := FALSE;

	bAllDone:= TRUE;
FOR M := 1 TO nNumMovers DO///Movers
	StopTimer[M](in:=StartTimer[m],PT:=StopTime);
	fbPlanarMover[M].nMoverId := nForCounter;
	fbPlanarMover[M].iTcIoXtsXpuMover := fbXtsEnvironment.XpuTcIo(1).MoverTcIo(TO_UINT(m));
	fbPlanarMover[M].Update();
	
	GVL_mc3.Mover[M].MoverPos  :=fbPlanarMover[M].McPlanarMover.MCTOPLC.SETONTRACK.SetPos;
	GVL_mc3.Mover[M].TrackID:= fbPlanarMover[M].McPlanarMover.MCTOPLC.SETONTRACK.TrackOID;
	GVL_mc3.Mover[M].MoverNumber := M;
	
	//MoverPos[M].SetValuesXYC(fbPlanarMover[M].McPlanarMover.MCTOPLC.SET.SetPos.x, fbPlanarMover[M].McPlanarMover.MCTOPLC.SET.SetPos.y,fbPlanarMover[M].McPlanarMover.MCTOPLC.SET.SetPos.c);
	
	TR := Tr+1;
	IF Tr = 4 THEN
		Tr :=1;
	END_IF
	ArcLength[M] :=GVL_Mc3.MC_Tracks[Tr].GetArcLengthClosestTo(MoverPos[M]);
	GVL_Mc3.MC_Tracks[Tr].GetPositionAt(ArcLength[M],TrackPos[M][Tr]);
	
	IF ABS(MoverPos[m].x - TrackPos[M][Tr].x) < 1 AND  ABS(MoverPos[m].y - TrackPos[M][Tr].y) < 1 THEN
 		GVL_mc3.Mover[M].MoverTrackNr := Tr;
	END_IF	
	
	
		
	IsMoverCommandedInShortcut := IsMoverCommandedInShortcut OR fbPlanarMover[M].IsCommandedInShortcut;
	IsMoverInBlockingArea := IsMoverInBlockingArea OR (Mover[M].TrackID = GVL_Mc3.MC_Tracks[E_TrackNum.main].MCTOPLC_STD.TrackOID AND IsBetween(value := Mover[M].MoverPos, minV := stSwitchConfig.fMagnetEntryPosn - stSwitchConfig.MagnetPosnComp, maxV :=  stSwitchConfig.fMagnetExitPosn + stSwitchConfig.MagnetPosnComp));
	MoverFeedback[M].Update();
	

	Fp_error(clk := fbPlanarMover[M].McPlanarMover.Error AND ncase= 100);
	IF Fp_error.Q THEN
		nCase := 140;
		Fault := TRUE;
		bMagnetOn := FALSE;
	END_IF
END_FOR

FOR T := 1 TO nNumMaxTracks DO 
	MC_Tracks[T].Update();
	MC_Trackfeedback[T].Update();
	
END_FOR

CASE nCase OF
	10:
		Fault := FALSE;
		FOR nForCounter := 1 TO fbXtsEnvironment.XpuTcIo(1).GetPartCount() DO
			fbXtsEnvironment.XpuTcIo(1).PartTcIo(TO_UINT(nForCounter)).TriggerReset();
		END_FOR
		
		nCase := 20;

	20:
		FOR T := 1 TO nNumMaxTracks DO 
			MC_Tracks[T].Enable(MC_Trackfeedback[T]);
		END_FOR
				nCase := 30;
		
		
	30: 
		IF MC_Trackfeedback[1].Done AND MC_Trackfeedback[2].Done AND MC_Trackfeedback[3].Done THEN
			nCase := 35;
		END_IF
		
		
	35:
		FOR nForCounter:=1 TO nNumMovers DO
			fbPlanarMover[nForCounter].McPlanarMover.Reset(MoverFeedback[nForCounter]);
		END_FOR
		nCase := 36;	
		
		
	36:	
		bAllDone:=TRUE;
		FOR nForCounter:=1 TO nNumMovers DO
			bAllDone:=bAllDone AND MoverFeedback[nForCounter].Done;
		END_FOR
		
		IF bAllDone THEN
			nCase := 40;
		END_IF
		
		
	40:
		FOR nForCounter:=1 TO nNumMovers DO
			fbPlanarMover[nForCounter].McPlanarMover.Enable(MoverFeedback[nForCounter]);
		END_FOR
		nCase := 50;
	
		
	50:
		bAllDone:=TRUE;
		FOR nForCounter:=1 TO nNumMovers DO
			bAllDone:=bAllDone AND MoverFeedback[nForCounter].Done;
		END_FOR
		
		IF bAllDone THEN
			nCase := 60;
		END_IF

	//55:

	60:
		FOR nForCounter:=1 TO  nNumMovers DO
			IF nForCounter <= 9 THEN
				fbPlanarMover[nForCounter].JoinTrack(MoverFeedback[nForCounter], GVL_Mc3.MC_Tracks[e_TrackNum.Big]);//   Mover[nForCounter].MoverTrackNr]);
			ELSE
				fbPlanarMover[nForCounter].JoinTrack(MoverFeedback[nForCounter], GVL_Mc3.MC_Tracks[e_TrackNum.Main]);
			END_IF	
		END_FOR
		
		nCase := 70;
		
		
	70:
		bAllDone:=TRUE;
		FOR nForCounter:=1 TO nNumMovers DO
			bAllDone:=bAllDone AND MoverFeedback[nForCounter].Done;
		END_FOR
		
		IF bAllDone THEN
			nCase := 80;
		END_IF
		
	80:	
		FOR nForCounter:=1 TO nNumMovers DO
			nMoveState[nForCounter] := 0;
			aMoveOnTrackOptions[nForCounter].direction := MC_Direction.mcDirectionPositive;
			aMoveOnTrackOptions[nForCounter].gapMode := MC_GAP_MODE_ON_TRACK.Fast1D;
		END_FOR
		
		nCase := 100;

	100:
		
		FOR nForCounter:=1 TO nNumMovers DO
			aDynamics[nForCounter].SetValuesVADJ(V := stMoverConfig.NormalVelo, A := stMoverConfig.NormalAccel, D := stMoverConfig.NormalDecel, J := stMoverConfig.NormalJerk);
			aMoveOnTrackOptions[nForCounter].gap:= stMoverConfig.MoverGap;
		END_FOR
		aDynamics[1].SetValuesVADJ(V := stMoverConfig.NormalVelo-stMoverConfig.VeloComp, A := stMoverConfig.NormalAccel, D := stMoverConfig.NormalDecel, J := stMoverConfig.NormalJerk);

		FOR nForCounter:=1 TO nNumMovers DO
			CASE nMoveState[nForCounter] OF
				
				0: // Track 3 Main Cycel 
					fbPlanarMover[nForCounter].McPlanarMover.MoveOnTrack(commandFeedback := MoverFeedback[nForCounter],
																		targetTrack := GVL_Mc3.MC_Tracks[E_TrackNum.Main],
																		targetPositionOnTrack := GVL_Mc3.MC_Tracks[E_TrackNum.Main].GetLength()-stTrackConfig.TargetPosnBeforeTrackEnd,
																		constraint := aDynamics[nForCounter],
																		options := aMoveOnTrackOptions[nForCounter]);
					nMoveState[nForCounter] := 10;
					
				10:
					IF Mover[nForCounter].MoverPos > GVL_Mc3.MC_Tracks[E_TrackNum.Main].GetLength()-stTrackConfig.ShortcutEntryDistance AND (Mover[nForCounter].TrackID = GVL_Mc3.MC_Tracks[E_TrackNum.Main].MCTOPLC_STD.TrackOID) THEN//     MCTrackOid_MainSemicircle THEN
						IF NOT Switch AND NOT SwitchOnly THEN
							nMoveState[nForCounter] := 20; // 20 - BigCycel
							IF NOT WithoutSwitch THEN
								Switch := TRUE;
							END_IF
						ELSE
							nMoveState[nForCounter] := 40;  // 40- SmallCycel
							IsMoverCommandedInShortcut := TRUE;
							Switch := FALSE;
						END_IF
					END_IF

				
				20:
					fbPlanarMover[nForCounter].McPlanarMover.MoveOnTrack(commandFeedback := MoverFeedback[nForCounter],
																		targetTrack := GVL_Mc3.MC_Tracks[E_TrackNum.Big],
																		targetPositionOnTrack := GVL_Mc3.MC_Tracks[E_TrackNum.Big].GetLength()-stTrackConfig.TargetPosnBeforeTrackEnd,
																		constraint := aDynamics[nForCounter],
																		options := aMoveOnTrackOptions[nForCounter]);		
					nMoveState[nForCounter] := 30;
				
					
				30:
				{warning 'What is the 4000 length?'}
					IF Mover[nForCounter].MoverPos > GVL_Mc3.MC_Tracks[E_TrackNum.Big].GetLength()-4000 AND  Mover[nForCounter].TrackID = GVL_Mc3.MC_Tracks[E_TrackNum.Big].MCTOPLC_STD.TrackOID    THEN//      MCTrackOid_BigSemicircle THEN
						nMoveState[nForCounter] := 60;
					END_IF				
				
			
				40:
				{warning 'What is the 100 length?'}
					fbPlanarMover[nForCounter].McPlanarMover.MoveOnTrack(commandFeedback := MoverFeedback[nForCounter],
																		targetTrack := GVL_Mc3.MC_Tracks[E_TrackNum.Small],
																		targetPositionOnTrack := GVL_Mc3.MC_Tracks[E_TrackNum.Small].GetLength()-100,
																		constraint := aDynamics[nForCounter],
																		options := aMoveOnTrackOptions[nForCounter]);					
					nMoveState[nForCounter] := 50;
			
				50:
					IF Mover[nForCounter].MoverPos > GVL_Mc3.MC_Tracks[E_TrackNum.small].GetLength()-stTrackConfig.ShortcutEntryDistance AND  Mover[nForCounter].TrackID = GVL_Mc3.MC_Tracks[E_TrackNum.Small].MCTOPLC_STD.TrackOID    THEN// MCTrackOid_Shortcut THEN
						nMoveState[nForCounter] := 60;
					END_IF
					
				60:
					IF  TestPowerMat  THEN
						nMoveState[nForCounter] := 70;
					ELSE
						nMoveState[nForCounter] := 0;	
					END_IF
				70:
					fbPlanarMover[nForCounter].McPlanarMover.MoveOnTrack(commandFeedback := MoverFeedback[nForCounter],
																		targetTrack := GVL_Mc3.MC_Tracks[E_TrackNum.Main],
																		targetPositionOnTrack := stTrackConfig.StopPos,
																		constraint := aDynamics[nForCounter],
																		options := aMoveOnTrackOptions[nForCounter]);					

					nMoveState[nForCounter] := 80;
				80:
					IF MoverFeedback[nForCounter].Done THEN
						StartTimer[nForCounter] := TRUE;
						nMoveState[nForCounter] := 85;
					END_IF
				85:
					IF 	StopTimer[nForCounter].Q THEN
						StartTimer[nForCounter] := FALSE;
						nMoveState[nForCounter] := 0;	
					END_IF
				END_CASE
		
		END_FOR

		IF bStopSequence AND NOT(IsMoverInBlockingArea) THEN
			nCase := 110;
			bStopSequence := FALSE;
		END_IF
		110:
			N:= nNumMovers;
			FOR nForCounter:=1 TO nNumMovers DO		
				GVL_General.aStopPositions[nForCounter] := TO_LREAL(  fbXtsEnvironment.XpuTcIo(1).MoverTcIo(TO_UINT(N)).GetSimulatedStartUpPosition());
				N := N -1;
			END_FOR
			nCase := 120;
		
		120:	
			nActStopPos := UDINT_TO_UINT(nNumMaxMovers-nNumMovers+1);
			FOR nForCounter:=1 TO nNumMovers DO
				aDynamics[nForCounter].SetValuesVADJ(V := stMoverConfig.StoppingVelo, A := stMoverConfig.NormalAccel, D := stMoverConfig.NormalDecel, J := stMoverConfig.NormalJerk);
				nMoveState[nForCounter] := 0;
				fbPlanarMover[nForCounter].McPlanarMover.MoveOnTrack(MoverFeedback[nForCounter], GVL_Mc3.MC_Tracks[E_TrackNum.main], 300, aDynamics[nForCounter],aMoveOnTrackOptions[nForCounter]);
			END_FOR

			nCase:= 130; 
		130:
			FOR nForCounter:=1 TO nNumMaxMovers - (nNumMovers-nNumMaxMovers)  DO
				CASE nMoveState[nForCounter] OF
					0:								
						
						IF Mover[nForCounter].MoverPos < 300 AND  Mover[nForCounter].TrackID = GVL_Mc3.MC_Tracks[E_TrackNum.main].MCTOPLC_STD.TrackOID THEN
							aMoveOnTrackOptions[nForCounter].gap:= 150;
							fbPlanarMover[nForCounter].McPlanarMover.MoveOnTrack(commandFeedback := MoverFeedback[nForCounter],
																				targetTrack := GVL_Mc3.MC_Tracks[E_TrackNum.Main],
																				targetPositionOnTrack := aStopPositions[nActStopPos],
																				constraint := aDynamics[nForCounter],
																				options := aMoveOnTrackOptions[nForCounter]);									
							nActStopPos := nActStopPos + 1;
							nMoveState[nForCounter] := 10;
						END_IF
				END_CASE
			END_FOR
		
			bAllDone := TRUE;
			FOR nForCounter:=1 TO nNumMovers DO
				IF NOT(MoverFeedback[nForCounter].Done OR MoverFeedback[nForCounter].Error) THEN
					bAllDone := FALSE;
					EXIT;
				END_IF
			END_FOR
			
			IF bAllDone THEN
				nCase := 150;
			END_IF
		
		140:
			FOR nForCounter:=1 TO nNumMovers DO
				fbPlanarMover[nForCounter].McPlanarMover.Halt(MoverFeedback[nForCounter], aDynamics[nForCounter]);
			END_FOR	
			
			nCase := 145;
			
		145:
			bAllDone := TRUE;
			FOR nForCounter:=1 TO nNumMovers DO
				IF NOT(MoverFeedback[nForCounter].Done OR MoverFeedback[nForCounter].Error) THEN
					bAllDone := FALSE;
					EXIT;
				END_IF
			END_FOR
			
			IF bAllDone THEN
				nCase := 150;
			END_IF
		
		//Disable
		150:
			FOR nForCounter:=1 TO nNumMovers DO
				fbPlanarMover[nForCounter].McPlanarMover.Disable(MoverFeedback[nForCounter]);
			END_FOR
				
			nCase := 0;
END_CASE

bMagnetOn := FALSE;
FOR nForCounter:=1 TO nNumMovers DO
	stPositionInfo := fbXtsEnvironment.XpuTcIo(1).MoverTcIo(TO_UINT(nForCounter)).GetPositionInfo();
	IF NOT Fault AND stPositionInfo.nTrackObjectId = XtsShortcutOid AND 
			(IsBetween(stPositionInfo.fTrackPosition, stSwitchConfig.fMagnetEntryPosn - (stMoverConfig.NormalVelo*stSwitchConfig.VeloPosnCalcEntry), 
			stSwitchConfig.fMagnetExitPosn - (stMoverConfig.NormalVelo*stSwitchConfig.VeloPosnCalcExit))) THEN
		bMagnetOn := TRUE;
	END_IF
	fbPlanarMover[nForCounter]();
END_FOR

pwm();
	
IF bMagnetOn AND NOT Fault THEN
	MagnetValue := SwitchCurrent*stSwitchConfig.CurrentMultFactor;
ELSE
 	MagnetValue := 0;
END_IF

FP_Counter(clk:=bMagnetOn);

IF FP_Counter.Q THEN
	Switchcounter := Switchcounter+1;
END_IF
]]></ST>
    </Implementation>
  </POU>
</TcPlcObject>