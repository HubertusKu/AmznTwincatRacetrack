<?xml version="1.0" encoding="utf-8"?>
<TcPlcObject Version="1.1.0.1">
  <POU Name="MAIN" Id="{66ade15a-bef8-4e71-a124-c2e5978c50eb}" SpecialFunc="None">
    <Declaration><![CDATA[PROGRAM MAIN
VAR
	ManMergeCmd				: BOOL;
	bAllDone					: BOOL;
	bStopSequence				: BOOL;
	                    		
	nCase 						: INT;
	nMoveState				  	: ARRAY[GC.nNumMinMovers..GC.nNumMaxMovers] OF INT;
	                    		
	fbXtsEnvironment			: Tc3_XTS_Utility.FB_TcIoXtsEnvironment;
	                    		
	nForCounter					: UDINT;
	M,N,T,Tr					: UDINT;
	dynamics				    : INT;

//Status
	xSimulation					: BOOL := TRUE;
	SystemEnabled				: BOOL;
	stPlcSystem					: ST_PlcSystem;

	IsMoverInBlockingArea		: BOOL;
	nActStopPos					: UINT := 1;
	Fp_error 					: Tc2_Standard.R_TRIG;
	FaultReset					: Tc2_Standard.R_TRIG;
	MoverStop 	AT%I* 			: BOOL;
  ResetSafetyLight AT%Q*      : BOOL;
	MoverStopDone AT%Q*			: BOOL;
	Info 		AT%Q*			: BOOL;
	Operating	AT%Q*			: BOOL;
	Process		AT%Q*			: BOOL;
	Fault		AT%Q*			: BOOL;
	Emergency	AT%Q*			: BOOL;
	                        	
	Voltage1	AT%I*			: UDINT;
	Voltage2	AT%I*			: UDINT;
	                        	
	TcRestart 					: Tc2_Utilities.TC_Restart;
	Restart 					: BOOL;
	busy 						: BOOL;
	fp_start 					: Tc2_Standard.R_TRIG;
	bStartSequence				: BOOL;
	                        	
	Horntimer 					: Tc2_Standard.TP; 
	R_trigHorn 					: Tc2_Standard.R_TRIG;

	StopTime 					: TIME := T#1S;
	StopTimer 					: ARRAY[GC.nNumMinMovers..GC.nNumMaxMovers] OF Tc2_Standard.TON;
	StartTimer 					: ARRAY[GC.nNumMinMovers..GC.nNumMaxMovers] OF BOOL;

	ArcLength 					: ARRAY[GC.nNumMinMovers..GC.nNumMaxMovers] OF LREAL;
	TrackPos					: ARRAY[GC.nNumMinMovers..GC.nNumMaxMovers] OF ARRAY[GC.nNumMinTracks..GC.nNumMaxTracks] OF Tc3_Physics.PositionXYC;
END_VAR
]]></Declaration>
    <Implementation>
      <ST><![CDATA[fbXtsEnvironment.Init(bExecute := TRUE);
//Cyclic
M_WritePlanarTrackConfig();
M_UpdateConfigurations();
IF xSimulation THEN
	SystemEnabled	:= TRUE;
ELSE
	SystemEnabled	:= (MoverStop (* SafetyOK *) AND NOT Fault);
END_IF

stPlcSystem.nTaskIdx := GETCURTASKINDEXEX();
IF stPlcSystem.nTaskIdx > 0 THEN
	stPlcSystem.nCycleTime := _TaskInfo[stPlcSystem.nTaskIdx].CycleTime;
	stPlcSystem.SysTime 	:= Tc2_System.F_GetSystemTime();
END_IF

//Command Diverting to Magnet for any designated mover
DivertQueue();
HistoryDivertQueue(); // no removal
MergeQueue();

//Check if any Mover using Magnet;
FOR nExitAMoverIsUsingMagnet :=  GC.nNumMinMovers TO GVL_General.nNumMovers DO
	IF fbPlanarXtsMover[nExitAMoverIsUsingMagnet].P_IsUsingMagnet THEN
		MagnetControlledByOtherMover		:= TRUE;
		EXIT;
	ELSE
		MagnetControlledByOtherMover		:= FALSE;
	END_IF
END_FOR

SwitchMagnet(SafetyPermIntlk := SystemEnabled,
			stSwitchConfig := GVL_General.stSwitchConfig);
ftMagnetControlledByOtherMover(CLK := MagnetControlledByOtherMover);

Emergency :=  MoverStop;
ResetSafetyLight    := NOT MoverStop;

Operating := NOT  MoverStop;
R_trigHorn(clk := Voltage1> 10000 OR Voltage2 >10000);
Horntimer(in:= ( R_trigHorn.Q ) , PT:= T#2S,Q=> info);

IF nCase > 90 THEN
	Process := TRUE;
ELSE 
	Process := FALSE;	
END_IF

IF NOT fbXtsEnvironment.P_IsInitialized THEN
	RETURN;
END_IF

IF NOT MoverStop AND NOT MoverStopDone THEN
	FOR nForCounter:=1 TO nNumMovers DO
		fbPlanarXtsMover[nForCounter].P_Dynamics.SetValuesVADJ(V := stMoverConfig.MaxVelo, A := stMoverConfig.MaxAccel, D := stMoverConfig.MaxDecel, J := stMoverConfig.HighJerk);
		nCase := 140;
		//fbPlanarMover[nForCounter].McPlanarMover.Halt(fbPlanarXtsMover[nForCounter].P_MoverFeedback, fbPlanarXtsMover[nForCounter].P_Dynamics);
	END_FOR		
	MoverStopDone := TRUE;
ELSIF MoverStop THEN
	MoverStopDone := FALSE;
END_IF


TcRestart(
NETID:= '', 
RESTART:= Restart, 
TMOUT:=T#5S , 
BUSY=>busy , 
ERR=> , 
ERRID=> );


fp_start(CLK := bStartSequence);
IF fp_start.Q THEN
	nCase := 10;
	bStartSequence := FALSE;
END_IF

//IsMoverCommandedInShortcut := FALSE;
IsMoverInBlockingArea := FALSE;

bAllDone:= TRUE;
FOR M := GC.nNumMinMovers TO GVL_General.nNumMovers DO///Movers
	StopTimer[M](in:=StartTimer[m],PT:=StopTime);
	GVL_Mc3.fbPlanarXtsMover[M].P_MoverId := M;
	GVL_Mc3.fbPlanarXtsMover[M].P_MoverSort.MoverNumber	:= GVL_Mc3.fbPlanarXtsMover[M].nMoverId;
  GVL_Mc3.aiXpuXtsMover[M]  := fbXtsEnvironment.XpuTcIo(1).MoverTcIo(TO_UINT(M));
  fbPlanarXtsMover[M].iTcIoXtsXpuMover REF= GVL_Mc3.aiXpuXtsMover[M];
	fbPlanarXtsMover[M].Update();
	
	//MoverPos[M].SetValuesXYC(fbPlanarMover[M].McPlanarMover.MCTOPLC.SET.SetPos.x, fbPlanarMover[M].McPlanarMover.MCTOPLC.SET.SetPos.y,fbPlanarMover[M].McPlanarMover.MCTOPLC.SET.SetPos.c);
	
	TR := Tr+1;
	IF Tr = 4 THEN
		Tr :=1;
	END_IF
	{warning <'MoverPhysics does not work'>}
	ArcLength[M] :=GVL_Mc3.MC_Tracks[Tr].GetArcLengthClosestTo(GVL_Mc3.fbPlanarXtsMover[M].P_Physics);
	GVL_Mc3.MC_Tracks[Tr].GetPositionAt(ArcLength[M],TrackPos[M][Tr]);
	
//	IF ABS(GVL_Mc3.fbPlanarXtsMover[M].MoverPhysics.x - TrackPos[M][Tr].x) < 1 AND  ABS(fbPlanarXtsMover[M].MoverPhysics.y - TrackPos[M][Tr].y) < 1 THEN
// 		GVL_Mc3.fbPlanarXtsMover[M].P_XPlanarMover.MoverTrackNr := Tr;
//	END_IF	
	
//	IsMoverCommandedInShortcut := IsMoverCommandedInShortcut OR fbPlanarXtsMover[M].IsCommandedInShortcut;
//	IsMoverInBlockingArea := IsMoverInBlockingArea OR (GVL_Mc3.fbPlanarXtsMover[M].P_PlanarMover.TrackID = GVL_Mc3.MC_Tracks[E_TrackNum.main].MCTOPLC_STD.TrackOID AND 
//														IsBetween(value := GVL_Mc3.fbPlanarXtsMover[M].P_PlanarMover.MoverPos, 
//														minV := GVL_General.stSwitchConfig.fMagnetEntryPosn - GVL_General.stSwitchConfig.MagnetPosnComp, 
//														maxV :=  GVL_General.stSwitchConfig.fMagnetExitPosn + stSwitchConfig.MagnetPosnComp));
	fbPlanarXtsMover[M].P_MoverFeedback.Update();

	Fp_error(CLK := fbPlanarXtsMover[M].P_MC_PlanarMover.Error AND nCase = 100);
	IF Fp_error.Q THEN
		nCase := 140;
		Fault := TRUE;
//		bCmdMagnetOn := FALSE;
	END_IF
END_FOR

FOR T := GC.nNumMinTracks TO GC.nNumMaxTracks DO 
	MC_Tracks[T].Update();
	MC_Trackfeedback[T].Update();
END_FOR

CASE nCase OF
	10:
		Fault := FALSE;
		FOR nForCounter := 1 TO fbXtsEnvironment.XpuTcIo(1).GetPartCount() DO
			fbXtsEnvironment.XpuTcIo(1).PartTcIo(TO_UINT(nForCounter)).TriggerReset();
		END_FOR
		
		nCase := 20;

	20:
		FOR T := GC.nNumMinTracks TO GC.nNumMaxTracks DO 
			MC_Tracks[T].Enable(MC_Trackfeedback[T]);
		END_FOR
				nCase := 30;
		
		
	30: 
		IF MC_Trackfeedback[E_TrackNum.Big].Done AND MC_Trackfeedback[E_TrackNum.Main].Done AND MC_Trackfeedback[E_TrackNum.Small].Done THEN
			nCase := 35;
		END_IF
		
		
	35:
		FOR nForCounter:=GC.nNumMinMovers TO GVL_General.nNumMovers DO
			fbPlanarXtsMover[nForCounter].P_MC_PlanarMover.Reset(fbPlanarXtsMover[nForCounter].P_MoverFeedback);
		END_FOR
		nCase := 36;	
		
		
	36:	
		bAllDone:=TRUE;
		FOR nForCounter:=GC.nNumMinMovers TO GVL_General.nNumMovers DO
			bAllDone:=bAllDone AND fbPlanarXtsMover[nForCounter].P_MoverFeedback.Done;
		END_FOR
		
		IF bAllDone THEN
			nCase := 40;
		END_IF
		
		
	40:
		FOR nForCounter:=GC.nNumMinMovers TO GVL_General.nNumMovers DO
			fbPlanarXtsMover[nForCounter].P_MC_PlanarMover.Enable(fbPlanarXtsMover[nForCounter].P_MoverFeedback);
		END_FOR
		nCase := 50;
	
		
	50:
		bAllDone:=TRUE;
		FOR nForCounter:=GC.nNumMinMovers TO GVL_General.nNumMovers DO
			bAllDone:=bAllDone AND fbPlanarXtsMover[nForCounter].P_MoverFeedback.Done;
		END_FOR
		
		IF bAllDone THEN
			nCase := 60;
		END_IF

	//55:

	60:
		FOR nForCounter:=GC.nNumMinMovers TO GVL_General.nNumMovers DO
			IF nForCounter <= 9 THEN
				fbPlanarXtsMover[nForCounter].JoinTrack(fbPlanarXtsMover[nForCounter].P_MoverFeedback, GVL_Mc3.MC_Tracks[E_TrackNum.Big]);//   Mover[nForCounter].MoverTrackNr]);
			ELSE
				fbPlanarXtsMover[nForCounter].JoinTrack(fbPlanarXtsMover[nForCounter].P_MoverFeedback, GVL_Mc3.MC_Tracks[E_TrackNum.Main]);
			END_IF	
		END_FOR
		
		nCase := 70;
		
	70:
		bAllDone:=TRUE;
		FOR nForCounter:=GC.nNumMinMovers TO GVL_General.nNumMovers DO
			bAllDone:=bAllDone AND fbPlanarXtsMover[nForCounter].P_MoverFeedback.Done;
		END_FOR
		
		IF bAllDone THEN
			nCase := 80;
		END_IF
		
	80:	
		FOR nForCounter:=GC.nNumMinMovers TO GVL_General.nNumMovers DO
			nMoveState[nForCounter] := 0;
			fbPlanarXtsMover[nForCounter].P_MoverOptions.BaseMoveOptions.direction := MC_Direction.mcDirectionPositive;
			fbPlanarXtsMover[nForCounter].P_MoverOptions.BaseMoveOptions.gapMode := MC_GAP_MODE_ON_TRACK.Fast1D;
		END_FOR
		
		nCase := 100;

	100:

		FOR nForCounter:= GC.nNumMinMovers TO GVL_General.nNumMovers DO
			
		//increased accel on shortcut
			IF TrackSectors[nForCounter].SectorStatus[GC.SHORTCUT_HD_SECTION].MoverIsOnSector THEN
				//Increase dynamics on Inner Shortcut
				fbPlanarXtsMover[nForCounter].P_Dynamics.SetValuesVADJ(V := stMoverConfig.NormalVelo, A := stMoverConfig.MaxAccel, D := stMoverConfig.MaxDecel, J := stMoverConfig.HighJerk);
			ELSE
				fbPlanarXtsMover[nForCounter].P_Dynamics.SetValuesVADJ(V := stMoverConfig.NormalVelo, A := stMoverConfig.NormalAccel, D := stMoverConfig.NormalDecel, J := stMoverConfig.NormalJerk);
			END_IF
			

			//Gap Control
			fbPlanarXtsMover[nForCounter].M_EvaluateGap(MoverIndex := nForCounter);

			//Adjust the first mover parameters to induce a platoon
			fbPlanarXtsMover[GC.nNumMinMovers].P_Dynamics.SetValuesVADJ(V := stMoverConfig.NormalVelo-stMoverConfig.VeloComp, A := stMoverConfig.NormalAccel, D := stMoverConfig.NormalDecel, J := stMoverConfig.NormalJerk);

			// allow updating the config per the HMI, when it will not jeopardize the system
			IF NOT TrackSectors[nForCounter].SectorStatus[GC.DIVERT_DECISION_OPART].MoverIsOnSector AND NOT 
				TrackSectors[nForCounter].SectorStatus[GC.SHORTCUT_ENTRY_HALF_IPART].MoverIsOnSector THEN
				stSwitchConfig.SwitchModeInternal		:= 						stSwitchConfig.SwitchModeHMI;
			END_IF
		
			TrackSectors[nForCounter](MoverIndex := nForCounter, MoverRef := iMover[nForCounter]);
//			HeadTrackSectors[nForCounter](MoverIndex := nForCounter, MoverRef := HeadExpMover[nForCounter]);
//			TailTrackSectors[nForCounter](MoverIndex := nForCounter, MoverRef := TailExpMover[nForCounter]);			
			AllTrackSectors(TrackSectorsRef := GVL_Mc3.TrackSectors, HeadTrackSectorsRef := HeadTrackSectors, TailTrackSectorsRef := TailTrackSectors);
			
			HeadExpMover[nForCounter](MoverRef := fbPlanarXtsMover[nForCounter]);
			TailExpMover[nForCounter](MoverRef := fbPlanarXtsMover[nForCounter]);
			AllExpMovers(HeadMoversRef := HeadExpMover, TailMoversRef := TailExpMover);
			
			iMover[nForCounter]	:= fbPlanarXtsMover[nForCounter];
			fbPlanarXtsMover[nForCounter]();
			
			CASE nMoveState[nForCounter] OF
				
				0: // Start-up/Init
					IF fbPlanarXtsMover[nForCounter].P_MoverSort.TrackID = GVL_General.PlanarTrackOuterFinish THEN
						fbPlanarXtsMover[nForCounter].P_MC_PlanarMover.MoveOnTrack(commandFeedback := fbPlanarXtsMover[nForCounter].P_MoverFeedback,
																			targetTrack := GVL_Mc3.MC_Tracks[E_TrackNum.Big],
																			targetPositionOnTrack := GVL_Mc3.MC_Tracks[E_TrackNum.Big].GetLength()-stTrackGlobalConfig.TargetPosnBeforeTrackEnd,
																			constraint := fbPlanarXtsMover[nForCounter].P_Dynamics,
																			options := fbPlanarXtsMover[nForCounter].P_MoverOptions.BaseMoveOptions);
						 nMoveState[nForCounter] 	:= 20;
					ELSIF (fbPlanarXtsMover[nForCounter].P_MoverSort.TrackID = GVL_General.PlanarTrackOuterStart) AND 
								fbPlanarXtsMover[nForCounter].P_XtsPositionInfo.fPartPosition < TrackSectors[nForCounter].P_SectorsConfig[GC.DIVERTQ_SECTOR_OPART].PartSectorStartPosn THEN
						fbPlanarXtsMover[nForCounter].P_MC_PlanarMover.MoveOnTrack(commandFeedback := fbPlanarXtsMover[nForCounter].P_MoverFeedback,
																			targetTrack := GVL_Mc3.MC_Tracks[E_TrackNum.Main],
																			targetPositionOnTrack := GVL_Mc3.MC_Tracks[E_TrackNum.Main].GetLength()-stTrackGlobalConfig.TargetPosnBeforeTrackEnd,
																			constraint := fbPlanarXtsMover[nForCounter].P_Dynamics,
																			options := fbPlanarXtsMover[nForCounter].P_MoverOptions.BaseMoveOptions);
						 nMoveState[nForCounter] 	:= 10;
					END_IF
					
				5: // In Recirc - from Big to Main Track - departing Gap Transition Zone - this Move command could be cyclic
					IF stPlcSystem.TempSysTime = 0 XOR stPlcSystem.TempSysTime = stPlcSystem.SysTime THEN
						stPlcSystem.TempSysTime := stPlcSystem.SysTime + (stPlcSystem.CfgIntervalExec * stPlcSystem.nCycleTime); //next valid clock to issue move command again
						fbPlanarXtsMover[nForCounter].P_eMerge		:= E_MergeType.NoMerge;
						fbPlanarXtsMover[nForCounter].P_MasterSyncId	:= 0;
						fbPlanarXtsMover[nForCounter].P_MasterSyncPosition	:= 0;
						fbPlanarXtsMover[nForCounter].P_MC_PlanarMover.MoveOnTrack(commandFeedback := fbPlanarXtsMover[nForCounter].P_MoverFeedback,
																		targetTrack := GVL_Mc3.MC_Tracks[E_TrackNum.Main],
																		targetPositionOnTrack := GVL_Mc3.MC_Tracks[E_TrackNum.Main].GetLength()-stTrackGlobalConfig.TargetPosnBeforeTrackEnd,
																		constraint := fbPlanarXtsMover[nForCounter].P_Dynamics, 
																		options := fbPlanarXtsMover[nForCounter].P_MoverOptions.BaseMoveOptions);
					END_IF
																		
					//Continuously call the above move command while GapInTransition TRUE (otherwise it's a one-shot command)
					IF NOT fbPlanarXtsMover[nForCounter].P_MoverOptions.GapInTransition THEN
						stPlcSystem.TempSysTime		:= 0;
						nMoveState[nForCounter] 	:= 10;
					END_IF

				10: //Trig state for decision to divert
					IF TrackSectors[nForCounter].afbSector[GC.DIVERTQ_SECTOR_OPART].stSectorStatus.MoverEnteredSector.Q THEN
						GVL_General.stSwitchStatus.ShuttleCountAtDivertTrig		:= GVL_General.stSwitchStatus.ShuttleCountAtDivertTrig +1; //always MODing this; don't need to decrement
						TempItvlMoverIndex	:= ((GVL_General.stSwitchStatus.ShuttleCountAtDivertTrig MOD GVL_General.stSwitchConfig.SwitchModeInternal.IntervalToDivert) +1); // capture the index
					//	AllTrackSectors.M_UpdateSectorCounts(SectorNr := GC.SHORTCUT_CALC_SECTOR_IPART);
						MoverIndexDivertTrig			:= fbPlanarXtsMover[nForCounter].P_MoverId; // regardless of the command to divert, log the MoverID
						DivertQueue.M_UpdateAtTrig();
						nMoveState[nForCounter] 	:= 12;
					END_IF
					
				12: // Command to move needs to be given early
					IF TrackSectors[nForCounter].afbSector[GC.DIVERT_DECISION_OPART].stSectorStatus.MoverEnteredSector.Q THEN
						DivertQueue.RemoveObjFromBuffer();
						nMoveState[nForCounter] 	:= 13;
					END_IF
				
				13:				
				IF (DivertQueue.P_LastObjectRemoved.MoverID <> 0) THEN // Valid MoverID must be obtained by Remove op in previous step
					IF SwitchMagnet.P_PermIntlkOK AND NOT MagnetControlledByOtherMover AND fbPlanarXtsMover[nForCounter].P_CmdDivert AND 
						(fbPlanarXtsMover[nForCounter].P_XtsPositionInfo.fPartPosition < GVL_Mc3.TrackSectors[nForCounter].P_SectorsConfig[GC.MAG_ON_SECTOR_OPART].PartSectorStartPosn)
						AND (stDivertingMover.SysTime <> DivertQueue.P_LastObjectRemoved.SysTime) THEN
							// Divert Move command
							stDivertingMover	:= DivertQueue.P_LastObjectRemoved;
							fbPlanarXtsMover[stDivertingMover.MoverID].P_MC_PlanarMover.MoveOnTrack(commandFeedback := fbPlanarXtsMover[stDivertingMover.MoverID].P_MoverFeedback,
																				targetTrack := GVL_Mc3.MC_Tracks[E_TrackNum.Small],
																				targetPositionOnTrack := (GVL_Mc3.MC_Tracks[E_TrackNum.Small].GetLength() - GC.SHUTTLE_LENGTH) / 2, // midpoint of shortcut
																				constraint := fbPlanarXtsMover[stDivertingMover.MoverID].P_Dynamics,
																				options := fbPlanarXtsMover[stDivertingMover.MoverID].P_MoverOptions.BaseMoveOptions);									
							nMoveState[nForCounter] 	:= 30; //Diverting Mover
					ELSIF NOT fbPlanarXtsMover[nForCounter].P_CmdDivert THEN
							nMoveState[nForCounter] 	:= 15;
					END_IF
				END_IF
	
				15: // In Recirc - from Main to Big Track
					fbPlanarXtsMover[nForCounter].P_MC_PlanarMover.MoveOnTrack(commandFeedback := fbPlanarXtsMover[nForCounter].P_MoverFeedback,
																		targetTrack := GVL_Mc3.MC_Tracks[E_TrackNum.Big],
																		targetPositionOnTrack := GVL_Mc3.MC_Tracks[E_TrackNum.Big].GetLength()-stTrackGlobalConfig.TargetPosnBeforeTrackEnd,
																		constraint := fbPlanarXtsMover[nForCounter].P_Dynamics,
																		options := fbPlanarXtsMover[nForCounter].P_MoverOptions.BaseMoveOptions);
					 nMoveState[nForCounter] 	:= 20;				
					
				20:
					IF TrackSectors[nForCounter].afbSector[GC.OUTER_BIGTRACK_END].stSectorStatus.MoverEnteredSector.Q THEN
						nMoveState[nForCounter]     := 5;
					END_IF				

				30: // Match the move command with the shuttle that is commanded to divert
					SwitchMagnet.M_EvaluateInlineCommands();
					
					IF ftMagnetControlledByOtherMover.Q THEN
						nMoveState[nForCounter] 	:= 40;
					END_IF
			
				40: // Route through shortcut
					IF TrackSectors[nForCounter].afbSector[GC.LOAD_STOP_SECTOR_IPART].stSectorStatus.MoverEnteredSector.Q THEN
						IF stTrackShortcutConfig.StopAtPowerMat THEN
							nMoveState[nForCounter] := 90;
						ELSE
							nMoveState[nForCounter] := 50;
						END_IF					
					END_IF
					
				50: //Pre-Merge state
				IF NOT AllTrackSectors.P_AMoverIsOnSector[GC.OUTER_BIGTRACK_LSMALL] 
						(*AND stSwitchConfig.SwitchModeInternal.MaxAllowedDivertCount = GVL_General.nNumMovers*) THEN
					fbPlanarXtsMover[nForCounter].P_eMerge := E_MergeType.FlyingMergeMoveOnTrack;

					fbPlanarXtsMover[nForCounter].P_MC_PlanarMover.MoveOnTrack(commandFeedback := fbPlanarXtsMover[nForCounter].P_MoverFeedback,
																		targetTrack := GVL_Mc3.MC_Tracks[E_TrackNum.Small],
																		targetPositionOnTrack := GVL_Mc3.MC_Tracks[E_TrackNum.Small].GetLength()-stTrackGlobalConfig.TargetPosnBeforeTrackEnd,
																		constraint := fbPlanarXtsMover[nForCounter].P_Dynamics,
																		options := fbPlanarXtsMover[nForCounter].P_MoverOptions.BaseMoveOptions);

					nMoveState[nForCounter] := 75;
					//Sync to Master ExpMover
				ELSIF TrackSectors[nForCounter].afbSector[GC.SHORTCUT_MERGE_COMMAND_FLYING].stSectorStatus.MoverEnteredSector.Q THEN
					//Nonzero means there is valid Master Mover data
					IF MergeQueue.P_LastObjectRemoved.MoverID <> 0 THEN
					fbPlanarXtsMover[nForCounter].P_eMerge				:= E_MergeType.FlyingMergeMoveSyncd;
						fbPlanarXtsMover[nForCounter].P_MasterSyncId := MergeQueue.P_LastObjectRemoved.MoverID;
//						IF MergeQueue.P_LastObjectRemoved.ExpMoverType = E_ExpMover.Head THEN
//							fbPlanarXtsMover[nForCounter].P_MasterSyncPosition	:= HeadExpMover[fbPlanarXtsMover[nForCounter].P_MasterSyncId].stExpMoverStatus.TrackSectorCenterHead;
//						ELSIF MergeQueue.P_LastObjectRemoved.ExpMoverType = E_ExpMover.Tail THEN
//							fbPlanarXtsMover[nForCounter].P_MasterSyncPosition	:= TailExpMover[fbPlanarXtsMover[nForCounter].P_MasterSyncId].stExpMoverStatus.TrackSectorCenterTail;
//						END_IF
							// use raw mover reference; likely need some position compensation, i.e, stTrackGlobalConfig.ExpMoverLength;
							fbPlanarXtsMover[nForCounter].P_MasterSyncPosition	:= fbPlanarXtsMover[fbPlanarXtsMover[nForCounter].P_MasterSyncId].P_XtsPositionInfo.fTrackPosition;							
						MergeQueue.ClearLastRemoved(); // master sync data consumed by slave
						nMoveState[nForCounter] := 72;					
					END_IF
					
				ELSIF TrackSectors[nForCounter].afbSector[GC.SHORTCUT_MERGE_COMMAND_WAIT].stSectorStatus.MoverEnteredSector.Q OR 
					stTrackShortcutConfig.StopAtPowerMat THEN
					fbPlanarXtsMover[nForCounter].P_eMerge := E_MergeType.MergeFromStaticSyncd;
					
					fbPlanarXtsMover[nForCounter].P_MC_PlanarMover.MoveOnTrack(commandFeedback := fbPlanarXtsMover[nForCounter].P_MoverFeedback,
																		targetTrack := GVL_Mc3.MC_Tracks[E_TrackNum.Small],
																		targetPositionOnTrack := GVL_Mc3.MC_Tracks[E_TrackNum.Small].GetLength()-stTrackGlobalConfig.MergeWaitFinishDistance-stTrackGlobalConfig.MergeWaitAccelDistance,
																		constraint := fbPlanarXtsMover[nForCounter].P_Dynamics,
																		options := fbPlanarXtsMover[nForCounter].P_MoverOptions.BaseMoveOptions);

					nMoveState[nForCounter] := 73;
				END_IF

				60: // Merge - Gear In
 //merge with gap zero
					//issue commmand to sync 
//					masterSyncPos := GVL_Mc.MC_Tracks[E_TrackNum.Big].GetLength()-100;
//					masterPosAtSync := Mover[moverInFront].MoverPos; 
//					followSyncPos := GVL_Mc.MC_Tracks[E_TrackNum.Small].GetLength()-1000;
//					followerPosAtSync :=Mover[1].MoverPos; 
//					fbMover[nForCounter].SyncToOtherMover( 
//						masterSyncPos := masterSyncPos,
//						masterTrack := GVL_Mc.MC_Tracks[E_TrackNum.Big],
//						followerSyncPos := followSyncPos,
//						followerTrack := GVL_Mc.MC_Tracks[e_TrackNum.Small],
//						PlanarMoverToFollow := fbMover[moverInFront].P_PlanarMover,
//						velo:= velo);
//						nMoveState[nForCounter] := 80; 
//					aggressiveDynamics.SetValuesVADJ(4000,4000,8000,400000); 
//					fbMover[nForCounter].P_Dynamics := aggressiveDynamics;
					//fbMover[nForCounter].MoveOnTrack(GVL_Mc.MC_Tracks[E_TrackNum.Main],  GVL_Mc.MC_Tracks[E_TrackNum.Main].GetLength()-500,900,velo);				
				
//					IF fbPlanarXtsMover[nForCounter].P_eMerge <> E_MergeType.NoMerge THEN
						fbPlanarXtsMover[nForCounter].P_Dynamics.SetValuesVADJ(V := stMoverConfig.NormalVelo, A := stMoverConfig.MaxAccel, D := stMoverConfig.MaxDecel, J := stMoverConfig.MergeJerk);
						
						fbPlanarXtsMover[nForCounter].P_MC_PlanarMover.GearInPosOnTrackWithMasterMover(
								commandFeedback:= fbPlanarXtsMover[nForCounter].P_PlanarFeedbackGearMM, 
								masterMover:= fbPlanarXtsMover[fbPlanarXtsMover[nForCounter].P_MasterSyncId].P_MC_PlanarMover,
								trackTrail:= fbPlanarXtsMover[nForCounter].P_SyncTrail,
								masterSyncPosition:= fbPlanarXtsMover[nForCounter].P_MasterSyncPosition,
								masterSyncPositionTrack:= GVL_Mc3.MC_Tracks[E_TrackNum.Big], 
								slaveSyncPosition:= fbPlanarXtsMover[nForCounter].P_XtsPositionInfo.fTrackPosition,
								slaveSyncPositionTrack:= GVL_Mc3.MC_Tracks[E_TrackNum.Small], 
								constraint:= fbPlanarXtsMover[nForCounter].P_Dynamics, 
								options:= fbPlanarXtsMover[nForCounter].P_MoverOptions.GearInMasterMoverOptions);
								nMoveState[nForCounter] := 74;
//					END_IF
						//fbPlanarXtsMover[nForCounter].P_InSync THEN				

				61:
				IF fbPlanarXtsMover[nForCounter].P_MoverFeedback.Done AND ManMergeCmd THEN
					ManMergeCmd	:= FALSE;
					nMoveState[nForCounter] := 75; // 62
				END_IF
					
				62:// Permissive to Merge
//					IF NOT AllTrackSectors.P_AMoverIsOnSector[GC.OUTER_MERGE_COLLISION] THEN
//						nMoveState[nForCounter] := 63;
//					END_IF

				63://Merge from Inner to Outer
//						fbPlanarXtsMover[nForCounter].P_MC_PlanarMover.MoveOnTrack(commandFeedback := fbPlanarXtsMover[nForCounter].P_MoverFeedback,
//																			targetTrack := GVL_Mc3.MC_Tracks[E_TrackNum.Small],
//																			targetPositionOnTrack := GVL_Mc3.MC_Tracks[E_TrackNum.Small].GetLength()-stTrackGlobalConfig.TargetPosnBeforeTrackEnd,
//																			constraint := fbPlanarXtsMover[nForCounter].P_Dynamics,
//																			options := fbPlanarXtsMover[nForCounter].P_MoverOptions.BaseMoveOptions);
//						nMoveState[nForCounter] := 75;
				
				75: //Reset Command On Exit
						IF TrackSectors[nForCounter].afbSector[GC.INNER_MERGE_TO_FINISH].stSectorStatus.MoverEnteredSector.Q THEN
							stSwitchStatus.ShuttleQueueCount := stSwitchStatus.ShuttleQueueCount -1;
							nMoveState[nForCounter] := 5;
						END_IF
				
				90: // Stopped at Powermat Station
					IF fbPlanarXtsMover[nForCounter].P_MoverFeedback.Done THEN
						StartTimer[nForCounter] := TRUE;
						nMoveState[nForCounter] := 100;
					END_IF
					
				100:
					IF StopTimer[nForCounter].Q THEN
						StartTimer[nForCounter] := FALSE;
						nMoveState[nForCounter] := 50;
					END_IF
				END_CASE
		
		END_FOR

		IF bStopSequence AND NOT(IsMoverInBlockingArea) THEN
			nCase := 110;
			bStopSequence := FALSE;
		END_IF
		110:
			N:= nNumMovers;
			FOR nForCounter:=1 TO nNumMovers DO		
				GVL_General.aStopPositions[nForCounter] := TO_LREAL(  fbXtsEnvironment.XpuTcIo(1).MoverTcIo(TO_UINT(N)).GetSimulatedStartUpPosition());
				N := N -1;
			END_FOR
			nCase := 120;
		
		120:	
			nActStopPos := UDINT_TO_UINT(GC.nNumMaxMovers-GVL_General.nNumMovers+1);
			FOR nForCounter:=1 TO nNumMovers DO
				fbPlanarXtsMover[nForCounter].P_Dynamics.SetValuesVADJ(V := stMoverConfig.StoppingVelo, A := stMoverConfig.NormalAccel, D := stMoverConfig.NormalDecel, J := stMoverConfig.NormalJerk);
				nMoveState[nForCounter] := 0;
				fbPlanarXtsMover[nForCounter].P_MC_PlanarMover.MoveOnTrack(fbPlanarXtsMover[nForCounter].P_MoverFeedback, GVL_Mc3.MC_Tracks[E_TrackNum.Main], 300, fbPlanarXtsMover[nForCounter].P_Dynamics, fbPlanarXtsMover[nForCounter].P_MoverOptions.BaseMoveOptions);
			END_FOR

			nCase:= 130; 
		130:
			FOR nForCounter:=1 TO GC.nNumMaxMovers - (GVL_General.nNumMovers-GC.nNumMaxMovers)  DO
				CASE nMoveState[nForCounter] OF
					0:								
						
						IF GVL_Mc3.fbPlanarXtsMover[nForCounter].P_MoverSort.MoverPos < 300 AND GVL_Mc3.fbPlanarXtsMover[nForCounter].P_MoverSort.TrackID = GVL_Mc3.MC_Tracks[E_TrackNum.main].MCTOPLC_STD.TrackOID THEN
							fbPlanarXtsMover[nForCounter].P_MoverOptions.BaseMoveOptions.gap:= stMoverConfig.TightMoverGap;
							fbPlanarXtsMover[nForCounter].P_MC_PlanarMover.MoveOnTrack(commandFeedback := fbPlanarXtsMover[nForCounter].P_MoverFeedback,
																				targetTrack := GVL_Mc3.MC_Tracks[E_TrackNum.Main],
																				targetPositionOnTrack := aStopPositions[nActStopPos],
																				constraint := fbPlanarXtsMover[nForCounter].P_Dynamics,
																				options := fbPlanarXtsMover[nForCounter].P_MoverOptions.BaseMoveOptions);									
							nActStopPos := nActStopPos + 1;
							nMoveState[nForCounter] := 10;
						END_IF
				END_CASE
			END_FOR
		
			bAllDone := TRUE;
			FOR nForCounter:=1 TO nNumMovers DO
				IF NOT(fbPlanarXtsMover[nForCounter].P_MoverFeedback.Done OR fbPlanarXtsMover[nForCounter].P_MoverFeedback.Error) THEN
					bAllDone := FALSE;
					EXIT;
				END_IF
			END_FOR
			
			IF bAllDone THEN
				nCase := 150;
			END_IF
		
		140:
			FOR nForCounter:=1 TO nNumMovers DO
				fbPlanarXtsMover[nForCounter].P_MC_PlanarMover.Halt(fbPlanarXtsMover[nForCounter].P_MoverFeedback, fbPlanarXtsMover[nForCounter].P_Dynamics);
			END_FOR	
			
			nCase := 145;
			
		145:
			bAllDone := TRUE;
			FOR nForCounter:=1 TO nNumMovers DO
				IF NOT(fbPlanarXtsMover[nForCounter].P_MoverFeedback.Done OR fbPlanarXtsMover[nForCounter].P_MoverFeedback.Error) THEN
					bAllDone := FALSE;
					EXIT;
				END_IF
			END_FOR
			
			IF bAllDone THEN
				nCase := 150;
			END_IF
		
		//Disable
		150:
			FOR nForCounter:=1 TO nNumMovers DO
				fbPlanarXtsMover[nForCounter].P_MC_PlanarMover.Disable(fbPlanarXtsMover[nForCounter].P_MoverFeedback);
			END_FOR
				
			nCase := 0;
END_CASE

FaultReset(CLK := MoverStop);

IF FaultReset.Q THEN
	Fault	:= FALSE;
END_IF
]]></ST>
    </Implementation>
    <Method Name="M_UpdateConfigurations" Id="{a2ceac5e-77e7-0f47-0d73-bb03330328f9}">
      <Declaration><![CDATA[METHOD M_UpdateConfigurations
]]></Declaration>
      <Implementation>
        <ST><![CDATA[stTrackGlobalConfig.MergeWaitAccelDistance := 
F_PosnDisp(Accel := stMoverConfig.MaxAccel, 
								VeloFinal := stMoverConfig.NormalVelo, 
								VeloInit := 0);]]></ST>
      </Implementation>
    </Method>
    <Method Name="M_WritePlanarTrackConfig" Id="{0295121c-55f9-0613-05f6-3ba76e5df670}">
      <Declaration><![CDATA[METHOD M_WritePlanarTrackConfig]]></Declaration>
      <Implementation>
        <ST><![CDATA[stPlanarTrackConfig[E_TrackNum.Big].MCTrack				:= GVL_Mc3.MC_Tracks[E_TrackNum.Big].MCTOPLC_STD;
stPlanarTrackConfig[E_TrackNum.Small].MCTrack			:= GVL_Mc3.MC_Tracks[E_TrackNum.Small].MCTOPLC_STD;
stPlanarTrackConfig[E_TrackNum.Main].MCTrack			:= GVL_Mc3.MC_Tracks[E_TrackNum.Main].MCTOPLC_STD;
                                                    	
stPlanarTrackConfig[E_TrackNum.Big].TrackIndex			:= E_TrackNum.Big;
stPlanarTrackConfig[E_TrackNum.Small].TrackIndex		:= E_TrackNum.Small;
stPlanarTrackConfig[E_TrackNum.Main].TrackIndex			:= E_TrackNum.Main;]]></ST>
      </Implementation>
    </Method>
  </POU>
</TcPlcObject>