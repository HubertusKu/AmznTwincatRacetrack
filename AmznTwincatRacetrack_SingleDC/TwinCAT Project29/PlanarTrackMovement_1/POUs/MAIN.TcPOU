<?xml version="1.0" encoding="utf-8"?>
<TcPlcObject Version="1.1.0.1">
  <POU Name="MAIN" Id="{66ade15a-bef8-4e71-a124-c2e5978c50eb}" SpecialFunc="None">
    <Declaration><![CDATA[PROGRAM MAIN
VAR
	bAllDone					: BOOL;
	bStopSequence				: BOOL;
	                    		
	nCase 						: INT;
	nMoveState				  	: ARRAY[GC.nNumMinMovers..GC.nNumMaxMovers] OF INT;
	                    		
	aDynamics					: ARRAY[GC.nNumMinMovers..GC.nNumMaxMovers] OF Tc3_Physics.DynamicConstraint_PathXY;
	aMoveOnTrackOptions   		: ARRAY[GC.nNumMinMCAxes..GC.nNumMaxMCAxes] OF Tc3_Mc3PlanarMotion.ST_MoveOnTrackOptions;
	                    		
	fbXtsEnvironment			: Tc3_XTS_Utility.FB_TcIoXtsEnvironment;
	                    		
	nForCounter					: UDINT;
	M,N,T,Tr					: UDINT;
	dynamics				    : INT;

//Status
	SystemEnabled				: BOOL;

	IsMoverInBlockingArea		: BOOL;
	nActStopPos					: UINT := 1;
	Fp_error 					: Tc2_Standard.R_TRIG;
	FaultReset					: Tc2_Standard.R_TRIG;
	MoverStop 	AT%I* 			: BOOL;
    ResetSafetyLight AT%Q*      : BOOL;
	MoverStopDone AT%Q*			: BOOL;
	Info 		AT%Q*			: BOOL;
	Operating	AT%Q*			: BOOL;
	Process		AT%Q*			: BOOL;
	Fault		AT%Q*			: BOOL;
	Emergency	AT%Q*			: BOOL;
	                        	
	Voltage1	AT%I*			: UDINT;
	Voltage2	AT%I*			: UDINT;
	                        	
	                        	
	TcRestart 					: Tc2_Utilities.TC_Restart;
	Restart 					: BOOL;
	busy 						: BOOL;
	fp_start 					: Tc2_Standard.R_TRIG;
	bStartSequence				: BOOL;
	                        	
	Horntimer 					: Tc2_Standard.TP; 
	R_trigHorn 					: Tc2_Standard.R_TRIG;

	StopTime 					: TIME := T#1S;
	StopTimer 					: ARRAY[GC.nNumMinMovers..GC.nNumMaxMovers] OF Tc2_Standard.TON;
	StartTimer 					: ARRAY[GC.nNumMinMovers..GC.nNumMaxMovers] OF BOOL;


	ArcLength 					: ARRAY[GC.nNumMinMovers..GC.nNumMaxMovers] OF LREAL;
	TrackPos					: ARRAY[GC.nNumMinMovers..GC.nNumMaxMovers] OF ARRAY[GC.nNumMinTracks..GC.nNumMaxTracks] OF Tc3_Physics.PositionXYC;
END_VAR
]]></Declaration>
    <Implementation>
      <ST><![CDATA[fbXtsEnvironment.Init(bExecute := TRUE);
//Cyclic
M_WritePlanarTrackConfig();
SystemEnabled	:= (MoverStop (* SafetyOK *) AND NOT Fault);

//Command Diverting to Magnet for any designated mover
DivertQueue();

SwitchMagnet(SafetyPermIntlk := SystemEnabled,
			stSwitchConfig := GVL_General.stSwitchConfig);

Emergency :=  MoverStop;
ResetSafetyLight    := NOT MoverStop;

Operating := NOT  MoverStop;
R_trigHorn(clk := Voltage1> 10000 OR Voltage2 >10000);
Horntimer(in:= ( R_trigHorn.Q ) , PT:= T#2S,Q=> info);

IF nCase > 90 THEN
	Process := TRUE;
ELSE 
	Process := FALSE;	
END_IF

IF NOT fbXtsEnvironment.P_IsInitialized THEN
	RETURN;
END_IF

IF NOT MoverStop AND NOT MoverStopDone THEN
	FOR nForCounter:=1 TO nNumMovers DO
		aDynamics[nForCounter].SetValuesVADJ(V := stMoverConfig.MaxVelo, A := stMoverConfig.MaxAccel, D := stMoverConfig.MaxDecel, J := stMoverConfig.MaxJerk);
		nCase := 140;
		//fbPlanarMover[nForCounter].McPlanarMover.Halt(MoverFeedback[nForCounter], aDynamics[nForCounter]);
	END_FOR		
	MoverStopDone := TRUE;
ELSIF MoverStop THEN
	MoverStopDone := FALSE;
END_IF


TcRestart(
NETID:= '', 
RESTART:= Restart, 
TMOUT:=T#5S , 
BUSY=>busy , 
ERR=> , 
ERRID=> );


fp_start(CLK := bStartSequence);
IF fp_start.Q THEN
	nCase := 10;
	bStartSequence := FALSE;
END_IF

//IsMoverCommandedInShortcut := FALSE;
IsMoverInBlockingArea := FALSE;

	bAllDone:= TRUE;
FOR M := GC.nNumMinMovers TO nNumMovers DO///Movers
	StopTimer[M](in:=StartTimer[m],PT:=StopTime);
	GVL_Mc3.fbPlanarXtsMover[M].P_MoverId := M;
	GVL_Mc3.fbPlanarXtsMover[M].P_PlanarMover.MoverNumber	:= GVL_Mc3.fbPlanarXtsMover[M].nMoverId;
  GVL_Mc3.aiXpuXtsMover[M]  := fbXtsEnvironment.XpuTcIo(1).MoverTcIo(TO_UINT(M));
  fbPlanarXtsMover[M].iTcIoXtsXpuMover REF= GVL_Mc3.aiXpuXtsMover[M];
	fbPlanarXtsMover[M].Update();
	
	//MoverPos[M].SetValuesXYC(fbPlanarMover[M].McPlanarMover.MCTOPLC.SET.SetPos.x, fbPlanarMover[M].McPlanarMover.MCTOPLC.SET.SetPos.y,fbPlanarMover[M].McPlanarMover.MCTOPLC.SET.SetPos.c);
	
	TR := Tr+1;
	IF Tr = 4 THEN
		Tr :=1;
	END_IF
	{warning <'MoverPhysics does not work'>}
	ArcLength[M] :=GVL_Mc3.MC_Tracks[Tr].GetArcLengthClosestTo(GVL_Mc3.fbPlanarXtsMover[M].P_MoverPhysics);
	GVL_Mc3.MC_Tracks[Tr].GetPositionAt(ArcLength[M],TrackPos[M][Tr]);
	
//	IF ABS(GVL_Mc3.fbPlanarXtsMover[M].MoverPhysics.x - TrackPos[M][Tr].x) < 1 AND  ABS(fbPlanarXtsMover[M].MoverPhysics.y - TrackPos[M][Tr].y) < 1 THEN
// 		GVL_Mc3.fbPlanarXtsMover[M].P_XPlanarMover.MoverTrackNr := Tr;
//	END_IF	
	
//	IsMoverCommandedInShortcut := IsMoverCommandedInShortcut OR fbPlanarXtsMover[M].IsCommandedInShortcut;
//	IsMoverInBlockingArea := IsMoverInBlockingArea OR (GVL_Mc3.fbPlanarXtsMover[M].P_PlanarMover.TrackID = GVL_Mc3.MC_Tracks[E_TrackNum.main].MCTOPLC_STD.TrackOID AND 
//														IsBetween(value := GVL_Mc3.fbPlanarXtsMover[M].P_PlanarMover.MoverPos, 
//														minV := GVL_General.stSwitchConfig.fMagnetEntryPosn - GVL_General.stSwitchConfig.MagnetPosnComp, 
//														maxV :=  GVL_General.stSwitchConfig.fMagnetExitPosn + stSwitchConfig.MagnetPosnComp));
	MoverFeedback[M].Update();
	

	Fp_error(CLK := fbPlanarXtsMover[M].McPlanarMover.Error AND nCase = 100);
	IF Fp_error.Q THEN
		nCase := 140;
		Fault := TRUE;
//		bCmdMagnetOn := FALSE;
	END_IF
END_FOR

FOR T := GC.nNumMinTracks TO GC.nNumMaxTracks DO 
	MC_Tracks[T].Update();
	MC_Trackfeedback[T].Update();
END_FOR

CASE nCase OF
	10:
		Fault := FALSE;
		FOR nForCounter := 1 TO fbXtsEnvironment.XpuTcIo(1).GetPartCount() DO
			fbXtsEnvironment.XpuTcIo(1).PartTcIo(TO_UINT(nForCounter)).TriggerReset();
		END_FOR
		
		nCase := 20;

	20:
		FOR T := GC.nNumMinTracks TO GC.nNumMaxTracks DO 
			MC_Tracks[T].Enable(MC_Trackfeedback[T]);
		END_FOR
				nCase := 30;
		
		
	30: 
		IF MC_Trackfeedback[E_TrackNum.Big].Done AND MC_Trackfeedback[E_TrackNum.Main].Done AND MC_Trackfeedback[E_TrackNum.Small].Done THEN
			nCase := 35;
		END_IF
		
		
	35:
		FOR nForCounter:=GC.nNumMinMovers TO GVL_General.nNumMovers DO
			fbPlanarXtsMover[nForCounter].McPlanarMover.Reset(MoverFeedback[nForCounter]);
		END_FOR
		nCase := 36;	
		
		
	36:	
		bAllDone:=TRUE;
		FOR nForCounter:=GC.nNumMinMovers TO GVL_General.nNumMovers DO
			bAllDone:=bAllDone AND MoverFeedback[nForCounter].Done;
		END_FOR
		
		IF bAllDone THEN
			nCase := 40;
		END_IF
		
		
	40:
		FOR nForCounter:=GC.nNumMinMovers TO GVL_General.nNumMovers DO
			fbPlanarXtsMover[nForCounter].McPlanarMover.Enable(MoverFeedback[nForCounter]);
		END_FOR
		nCase := 50;
	
		
	50:
		bAllDone:=TRUE;
		FOR nForCounter:=GC.nNumMinMovers TO GVL_General.nNumMovers DO
			bAllDone:=bAllDone AND MoverFeedback[nForCounter].Done;
		END_FOR
		
		IF bAllDone THEN
			nCase := 60;
		END_IF

	//55:

	60:
		FOR nForCounter:=GC.nNumMinMovers TO GVL_General.nNumMovers DO
			IF nForCounter <= 9 THEN
				fbPlanarXtsMover[nForCounter].JoinTrack(MoverFeedback[nForCounter], GVL_Mc3.MC_Tracks[E_TrackNum.Big]);//   Mover[nForCounter].MoverTrackNr]);
			ELSE
				fbPlanarXtsMover[nForCounter].JoinTrack(MoverFeedback[nForCounter], GVL_Mc3.MC_Tracks[E_TrackNum.Main]);
			END_IF	
		END_FOR
		
		nCase := 70;
		
		
	70:
		bAllDone:=TRUE;
		FOR nForCounter:=GC.nNumMinMovers TO GVL_General.nNumMovers DO
			bAllDone:=bAllDone AND MoverFeedback[nForCounter].Done;
		END_FOR
		
		IF bAllDone THEN
			nCase := 80;
		END_IF
		
	80:	
		FOR nForCounter:=GC.nNumMinMovers TO GVL_General.nNumMovers DO
			nMoveState[nForCounter] := 0;
			aMoveOnTrackOptions[nForCounter].direction := MC_Direction.mcDirectionPositive;
			aMoveOnTrackOptions[nForCounter].gapMode := MC_GAP_MODE_ON_TRACK.Fast1D;
		END_FOR
		
		nCase := 100;

	100:

		FOR nForCounter:= GC.nNumMinMovers TO GVL_General.nNumMovers DO
			IF TrackSectors[nForCounter].SingularSectorStatus[GC.SHORTCUT_EXIT_SECTOR_IPART].MoverIsOnSector THEN
				//Reduce mover-mover gap
				aMoveOnTrackOptions[nForCounter].gap:= stMoverConfig.TightMoverGap;
			ELSIF TrackSectors[nForCounter].SingularSectorStatus[GC.MERGE_SECTOR_TO_FINISH].MoverIsOnSector THEN
				//Increase acceleration
				aDynamics[nForCounter].SetValuesVADJ(V := stMoverConfig.NormalVelo, A := stMoverConfig.MaxAccel, D := stMoverConfig.NormalDecel, J := stMoverConfig.NormalJerk);
			ELSE
				aDynamics[nForCounter].SetValuesVADJ(V := stMoverConfig.NormalVelo, A := stMoverConfig.NormalAccel, D := stMoverConfig.NormalDecel, J := stMoverConfig.NormalJerk);
				aMoveOnTrackOptions[nForCounter].gap:= stMoverConfig.NormalMoverGap;
			END_IF

			//Adjust the first mover parameters to induce a platoon
			aDynamics[GC.nNumMinMovers].SetValuesVADJ(V := stMoverConfig.NormalVelo-stMoverConfig.VeloComp, A := stMoverConfig.NormalAccel, D := stMoverConfig.NormalDecel, J := stMoverConfig.NormalJerk);

			IF NOT TrackSectors[nForCounter].DivertTrigQueueSectorStatus.MoverIsOnSector THEN
				stSwitchConfig.SwitchModeInternal		:= 						stSwitchConfig.SwitchModeHMI;
			END_IF
		
			GVL_Mc3.TrackSectors[nForCounter](MoverIndex := nForCounter);
		
			fbPlanarXtsMover[nForCounter]();

			CASE nMoveState[nForCounter] OF
				
				0: // Track 3 Main Cycle
					fbPlanarXtsMover[nForCounter].McPlanarMover.MoveOnTrack(commandFeedback := MoverFeedback[nForCounter],
																		targetTrack := GVL_Mc3.MC_Tracks[E_TrackNum.Main],
																		targetPositionOnTrack := GVL_Mc3.MC_Tracks[E_TrackNum.Main].GetLength()-stTrackGlobalConfig.TargetPosnBeforeTrackEnd,
																		constraint := aDynamics[nForCounter],
																		options := aMoveOnTrackOptions[nForCounter]);
					nMoveState[nForCounter] := 10;

				10: //Decision state to route mover through the switch or continue on the outer loop
					IF TrackSectors[nForCounter].afbSector[GC.MAG_TRIG_SECTOR_OPART_END].stTrackSectorStatus.MoverEnteredSector.Q THEN
						DivertQueue.M_UpdateAtTrig();
						nMoveState[nForCounter] 	:= 15;
					END_IF
					
				15: // Match the move command with the shuttle that is commanded to divert
					IF SwitchMagnet.PermIntlkOK AND (fbPlanarXtsMover[nForCounter].P_MoverId = DivertQueue.DivertingMoverIndex) THEN
						 nMoveState[nForCounter] 	:= 20;
					ELSE
						 nMoveState[nForCounter] 	:= 30;
					END_IF

				20: // Move command to inner track
					fbPlanarXtsMover[nForCounter].McPlanarMover.MoveOnTrack(commandFeedback := MoverFeedback[nForCounter],
																		targetTrack := GVL_Mc3.MC_Tracks[E_TrackNum.Small],
																		targetPositionOnTrack := (GVL_Mc3.MC_Tracks[E_TrackNum.Small].GetLength() / 2), // midpoint of shortcut
																		constraint := aDynamics[nForCounter],
																		options := aMoveOnTrackOptions[nForCounter]);
																		
					nMoveState[nForCounter] := 50;

				30: //Move command to outer track (continue straight)
					fbPlanarXtsMover[nForCounter].McPlanarMover.MoveOnTrack(commandFeedback := MoverFeedback[nForCounter],
																		targetTrack := GVL_Mc3.MC_Tracks[E_TrackNum.Big],
																		targetPositionOnTrack := GVL_Mc3.MC_Tracks[E_TrackNum.Big].GetLength()-stTrackGlobalConfig.TargetPosnBeforeTrackEnd,
																		constraint := aDynamics[nForCounter],
																		options := aMoveOnTrackOptions[nForCounter]);	
					nMoveState[nForCounter] := 40;


				40:
					IF TrackSectors[nForCounter].afbSector[GC.NO_DIVERT_POST_MAG].stTrackSectorStatus.MoverExitedSector.Q THEN // did not divert
						nMoveState[nForCounter]     := 0;
					END_IF
				
				
				50: // Confirm the shuttle is diverting
					IF TrackSectors[nForCounter].afbSector[GC.SHORTCUT_ENTRY_SECTOR_IPART].stTrackSectorStatus.MoverExitedSector.Q THEN
						nMoveState[nForCounter] := 55;
					END_IF
			
				55: // Route through shortcut
					IF stTrackShortcutConfig.TestPowerMat THEN
						IF TrackSectors[nForCounter].afbSector[GC.LOAD_STOP_SECTOR_IPART].stTrackSectorStatus.MoverEnteredSector.Q THEN
							nMoveState[nForCounter] := 70;
						END_IF
					ELSE
						nMoveState[nForCounter] := 60;
					END_IF
					
				60:
					fbPlanarXtsMover[nForCounter].McPlanarMover.MoveOnTrack(commandFeedback := MoverFeedback[nForCounter],
																		targetTrack := GVL_Mc3.MC_Tracks[E_TrackNum.Small],
																		targetPositionOnTrack := GVL_Mc3.MC_Tracks[E_TrackNum.Small].GetLength()-stTrackGlobalConfig.TargetPosnBeforeTrackEnd,
																		constraint := aDynamics[nForCounter],
																		options := aMoveOnTrackOptions[nForCounter]);
					nMoveState[nForCounter] := 0;

				70:
//					GVL_Mc3.fbPlanarXtsMover[nForCounter].McPlanarMover.MoveOnTrack(commandFeedback := MoverFeedback[nForCounter],
//																		targetTrack := GVL_Mc3.MC_Tracks[E_TrackNum.Main],
//																		targetPositionOnTrack := stTrackGlobalConfig.StopPosPowermat,
//																		constraint := aDynamics[nForCounter],
//																		options := aMoveOnTrackOptions[nForCounter]);					

					IF MoverFeedback[nForCounter].Done THEN
						StartTimer[nForCounter] := TRUE;
						nMoveState[nForCounter] := 80;
					END_IF
					
				80:
					IF 	StopTimer[nForCounter].Q THEN
						StartTimer[nForCounter] := FALSE;
						nMoveState[nForCounter] := 60;	
					END_IF
				END_CASE
		
		END_FOR

		IF bStopSequence AND NOT(IsMoverInBlockingArea) THEN
			nCase := 110;
			bStopSequence := FALSE;
		END_IF
		110:
			N:= nNumMovers;
			FOR nForCounter:=1 TO nNumMovers DO		
				GVL_General.aStopPositions[nForCounter] := TO_LREAL(  fbXtsEnvironment.XpuTcIo(1).MoverTcIo(TO_UINT(N)).GetSimulatedStartUpPosition());
				N := N -1;
			END_FOR
			nCase := 120;
		
		120:	
			nActStopPos := UDINT_TO_UINT(GC.nNumMaxMovers-nNumMovers+1);
			FOR nForCounter:=1 TO nNumMovers DO
				aDynamics[nForCounter].SetValuesVADJ(V := stMoverConfig.StoppingVelo, A := stMoverConfig.NormalAccel, D := stMoverConfig.NormalDecel, J := stMoverConfig.NormalJerk);
				nMoveState[nForCounter] := 0;
				fbPlanarXtsMover[nForCounter].McPlanarMover.MoveOnTrack(MoverFeedback[nForCounter], GVL_Mc3.MC_Tracks[E_TrackNum.Main], 300, aDynamics[nForCounter],aMoveOnTrackOptions[nForCounter]);
			END_FOR

			nCase:= 130; 
		130:
			FOR nForCounter:=1 TO GC.nNumMaxMovers - (nNumMovers-GC.nNumMaxMovers)  DO
				CASE nMoveState[nForCounter] OF
					0:								
						
						IF GVL_Mc3.fbPlanarXtsMover[nForCounter].P_PlanarMover.MoverPos < 300 AND GVL_Mc3.fbPlanarXtsMover[nForCounter].P_PlanarMover.TrackID = GVL_Mc3.MC_Tracks[E_TrackNum.main].MCTOPLC_STD.TrackOID THEN
							aMoveOnTrackOptions[nForCounter].gap:= stMoverConfig.TightMoverGap;
							fbPlanarXtsMover[nForCounter].McPlanarMover.MoveOnTrack(commandFeedback := MoverFeedback[nForCounter],
																				targetTrack := GVL_Mc3.MC_Tracks[E_TrackNum.Main],
																				targetPositionOnTrack := aStopPositions[nActStopPos],
																				constraint := aDynamics[nForCounter],
																				options := aMoveOnTrackOptions[nForCounter]);									
							nActStopPos := nActStopPos + 1;
							nMoveState[nForCounter] := 10;
						END_IF
				END_CASE
			END_FOR
		
			bAllDone := TRUE;
			FOR nForCounter:=1 TO nNumMovers DO
				IF NOT(MoverFeedback[nForCounter].Done OR MoverFeedback[nForCounter].Error) THEN
					bAllDone := FALSE;
					EXIT;
				END_IF
			END_FOR
			
			IF bAllDone THEN
				nCase := 150;
			END_IF
		
		140:
			FOR nForCounter:=1 TO nNumMovers DO
				fbPlanarXtsMover[nForCounter].McPlanarMover.Halt(MoverFeedback[nForCounter], aDynamics[nForCounter]);
			END_FOR	
			
			nCase := 145;
			
		145:
			bAllDone := TRUE;
			FOR nForCounter:=1 TO nNumMovers DO
				IF NOT(MoverFeedback[nForCounter].Done OR MoverFeedback[nForCounter].Error) THEN
					bAllDone := FALSE;
					EXIT;
				END_IF
			END_FOR
			
			IF bAllDone THEN
				nCase := 150;
			END_IF
		
		//Disable
		150:
			FOR nForCounter:=1 TO nNumMovers DO
				fbPlanarXtsMover[nForCounter].McPlanarMover.Disable(MoverFeedback[nForCounter]);
			END_FOR
				
			nCase := 0;
END_CASE

FaultReset(CLK := MoverStop);

IF FaultReset.Q THEN
	Fault	:= FALSE;
END_IF
]]></ST>
    </Implementation>
    <Method Name="M_WritePlanarTrackConfig" Id="{0295121c-55f9-0613-05f6-3ba76e5df670}">
      <Declaration><![CDATA[METHOD M_WritePlanarTrackConfig]]></Declaration>
      <Implementation>
        <ST><![CDATA[stPlanarTrackConfig[E_TrackNum.Big].MCTrack				:= GVL_Mc3.MC_Tracks[E_TrackNum.Big].MCTOPLC_STD;
stPlanarTrackConfig[E_TrackNum.Small].MCTrack			:= GVL_Mc3.MC_Tracks[E_TrackNum.Small].MCTOPLC_STD;
stPlanarTrackConfig[E_TrackNum.Main].MCTrack			:= GVL_Mc3.MC_Tracks[E_TrackNum.Main].MCTOPLC_STD;
                                                    	
stPlanarTrackConfig[E_TrackNum.Big].TrackIndex			:= E_TrackNum.Big;
stPlanarTrackConfig[E_TrackNum.Small].TrackIndex		:= E_TrackNum.Small;
stPlanarTrackConfig[E_TrackNum.Main].TrackIndex			:= E_TrackNum.Main;]]></ST>
      </Implementation>
    </Method>
  </POU>
</TcPlcObject>