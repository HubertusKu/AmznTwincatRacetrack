<?xml version="1.0" encoding="utf-8"?>
<TcPlcObject Version="1.1.0.1">
  <POU Name="MAIN" Id="{66ade15a-bef8-4e71-a124-c2e5978c50eb}" SpecialFunc="None">
    <Declaration><![CDATA[PROGRAM MAIN
VAR
	bAllDone					: BOOL;
	bStopSequence				: BOOL;
	                    		
	nCase 						: INT;
	nMoveState				  	: ARRAY[GC.nNumMinMovers..GC.nNumMaxMovers] OF INT;
	                    		
	aDynamics					: ARRAY[GC.nNumMinMovers..GC.nNumMaxMovers] OF Tc3_Physics.DynamicConstraint_PathXY;
	aMoveOnTrackOptions   		: ARRAY[GC.nNumMinMCAxes..GC.nNumMaxMCAxes] OF Tc3_Mc3PlanarMotion.ST_MoveOnTrackOptions;
	                    		
	fbXtsEnvironment			: Tc3_XTS_Utility.FB_TcIoXtsEnvironment;
	                    		
	nForCounter					: UDINT;
	M,N,T,Tr					: UDINT;
	dynamics				    : INT;

//Status

//
	pwm							: FB_PWM;
	bCmdMagnetOn				: BOOL;
	MagnetEnabled				: BOOL;
	SwitchMagnet				: FB_SwitchMagnet;
	
	IsMoverCommandedInShortcut	: BOOL;
	IsMoverInBlockingArea		: BOOL;
	nActStopPos					: UINT := 1;
	Fp_error 					: R_Trig;
	
	MoverStop 	AT%I* 			: BOOL;
    ResetSafetyLight AT%Q*      : BOOL;
	MoverStopDone AT%Q*			: BOOL;
	Info 		AT%Q*			: BOOL;
	Operating	AT%Q*			: BOOL;
	Process		AT%Q*			: BOOL;
	Fault		AT%Q*			: BOOL;
	Emergency	AT%Q*			: BOOL;
	                        	
	Voltage1	AT%I*			: UDINT;
	Voltage2	AT%I*			: UDINT;
	                        	
	                        	
	TcRestart 					: Tc2_Utilities.TC_Restart;
	Restart 					: BOOL;
	busy 						: BOOL;
	fp_start 					: Tc2_Standard.R_TRIG;
	bStartSequence				: BOOL;
	                        	
	FP_Counter 					: Tc2_Standard.R_TRIG;
	Switchcounter 				: DINT;
	test 						: LREAL;
	Horntimer 					: Tc2_Standard.TP; 
	R_trigHorn 					: Tc2_Standard.R_TRIG;
	                        	
	StopTime 					: TIME := T#8S;
	StopTimer 					: ARRAY[GC.nNumMinMovers..GC.nNumMaxMovers] OF Tc2_Standard.TON;
	StartTimer 					: ARRAY[GC.nNumMinMovers..GC.nNumMaxMovers] OF BOOL;


	ArcLength 					: ARRAY[GC.nNumMinMovers..GC.nNumMaxMovers] OF LREAL;
	TrackPos					: ARRAY[GC.nNumMinMovers..GC.nNumMaxMovers] OF ARRAY[GC.nNumMinTracks..GC.nNumMaxTracks] OF Tc3_Physics.PositionXYC;
END_VAR
]]></Declaration>
    <Implementation>
      <ST><![CDATA[//IF NOT fbXtsEnvironment.P_IsInitialized THEN
	fbXtsEnvironment.Init(bExecute := TRUE);
	//Cyclic
M_WritePlanarTrackConfig();
//END_IF

Emergency :=  MoverStop;
ResetSafetyLight    := NOT MoverStop;

Operating := NOT  MoverStop;
R_trigHorn(clk := Voltage1> 10000 OR Voltage2 >10000);
Horntimer(in:= ( R_trigHorn.Q ) , PT:= T#2S,Q=> info);

IF nCase > 90 THEN
	Process := TRUE;
ELSE 
	Process := FALSE;	
END_IF

IF NOT fbXtsEnvironment.P_IsInitialized THEN
	RETURN;
END_IF

IF NOT MoverStop AND NOT MoverStopDone THEN
	FOR nForCounter:=1 TO nNumMovers DO
		aDynamics[nForCounter].SetValuesVADJ(V := stMoverConfig.MaxVelo, A := stMoverConfig.MaxAccel, D := stMoverConfig.MaxDecel, J := stMoverConfig.MaxJerk);
		nCase := 140;
		//fbPlanarMover[nForCounter].McPlanarMover.Halt(MoverFeedback[nForCounter], aDynamics[nForCounter]);
	END_FOR		
	MoverStopDone := TRUE;
ELSIF MoverStop THEN
	MoverStopDone := FALSE;
END_IF


TcRestart(
NETID:= '', 
RESTART:= Restart, 
TMOUT:=T#5S , 
BUSY=>busy , 
ERR=> , 
ERRID=> );


fp_start(CLK := bStartSequence);
IF fp_start.Q THEN
	nCase := 10;
	bStartSequence := FALSE;
END_IF

//IsMoverCommandedInShortcut := FALSE;
IsMoverInBlockingArea := FALSE;

	bAllDone:= TRUE;
FOR M := 1 TO nNumMovers DO///Movers
	StopTimer[M](in:=StartTimer[m],PT:=StopTime);
	GVL_Mc3.fbPlanarXtsMover[M].nMoverId := M;
	GVL_Mc3.fbPlanarXtsMover[M].P_PlanarMover.MoverNumber	:= GVL_Mc3.fbPlanarXtsMover[M].nMoverId;
  GVL_Mc3.aiXpuXtsMover[M]  := fbXtsEnvironment.XpuTcIo(1).MoverTcIo(TO_UINT(M));
  fbPlanarXtsMover[M].iTcIoXtsXpuMover REF= GVL_Mc3.aiXpuXtsMover[M];
	fbPlanarXtsMover[M].Update();
	
	//MoverPos[M].SetValuesXYC(fbPlanarMover[M].McPlanarMover.MCTOPLC.SET.SetPos.x, fbPlanarMover[M].McPlanarMover.MCTOPLC.SET.SetPos.y,fbPlanarMover[M].McPlanarMover.MCTOPLC.SET.SetPos.c);
	
	TR := Tr+1;
	IF Tr = 4 THEN
		Tr :=1;
	END_IF
	{warning <'MoverPhysics does not work'>}
	ArcLength[M] :=GVL_Mc3.MC_Tracks[Tr].GetArcLengthClosestTo(GVL_Mc3.fbPlanarXtsMover[M].P_MoverPhysics);
	GVL_Mc3.MC_Tracks[Tr].GetPositionAt(ArcLength[M],TrackPos[M][Tr]);
	
//	IF ABS(GVL_Mc3.fbPlanarXtsMover[M].MoverPhysics.x - TrackPos[M][Tr].x) < 1 AND  ABS(fbPlanarXtsMover[M].MoverPhysics.y - TrackPos[M][Tr].y) < 1 THEN
// 		GVL_Mc3.fbPlanarXtsMover[M].P_XPlanarMover.MoverTrackNr := Tr;
//	END_IF	
	
//	IsMoverCommandedInShortcut := IsMoverCommandedInShortcut OR fbPlanarXtsMover[M].IsCommandedInShortcut;
//	IsMoverInBlockingArea := IsMoverInBlockingArea OR (GVL_Mc3.fbPlanarXtsMover[M].P_PlanarMover.TrackID = GVL_Mc3.MC_Tracks[E_TrackNum.main].MCTOPLC_STD.TrackOID AND 
//														IsBetween(value := GVL_Mc3.fbPlanarXtsMover[M].P_PlanarMover.MoverPos, 
//														minV := GVL_General.stSwitchConfig.fMagnetEntryPosn - GVL_General.stSwitchConfig.MagnetPosnComp, 
//														maxV :=  GVL_General.stSwitchConfig.fMagnetExitPosn + stSwitchConfig.MagnetPosnComp));
	MoverFeedback[M].Update();
	

	Fp_error(CLK := fbPlanarXtsMover[M].McPlanarMover.Error AND nCase = 100);
	IF Fp_error.Q THEN
		nCase := 140;
		Fault := TRUE;
//		bCmdMagnetOn := FALSE;
	END_IF
END_FOR

FOR T := 1 TO GC.nNumMaxTracks DO 
	MC_Tracks[T].Update();
	MC_Trackfeedback[T].Update();
	
END_FOR

CASE nCase OF
	10:
		Fault := FALSE;
		FOR nForCounter := 1 TO fbXtsEnvironment.XpuTcIo(1).GetPartCount() DO
			fbXtsEnvironment.XpuTcIo(1).PartTcIo(TO_UINT(nForCounter)).TriggerReset();
		END_FOR
		
		nCase := 20;

	20:
		FOR T := 1 TO GC.nNumMaxTracks DO 
			MC_Tracks[T].Enable(MC_Trackfeedback[T]);
		END_FOR
				nCase := 30;
		
		
	30: 
		IF MC_Trackfeedback[E_TrackNum.Big].Done AND MC_Trackfeedback[E_TrackNum.Main].Done AND MC_Trackfeedback[E_TrackNum.Small].Done THEN
			nCase := 35;
		END_IF
		
		
	35:
		FOR nForCounter:=1 TO nNumMovers DO
			fbPlanarXtsMover[nForCounter].McPlanarMover.Reset(MoverFeedback[nForCounter]);
		END_FOR
		nCase := 36;	
		
		
	36:	
		bAllDone:=TRUE;
		FOR nForCounter:=1 TO nNumMovers DO
			bAllDone:=bAllDone AND MoverFeedback[nForCounter].Done;
		END_FOR
		
		IF bAllDone THEN
			nCase := 40;
		END_IF
		
		
	40:
		FOR nForCounter:=1 TO nNumMovers DO
			fbPlanarXtsMover[nForCounter].McPlanarMover.Enable(MoverFeedback[nForCounter]);
		END_FOR
		nCase := 50;
	
		
	50:
		bAllDone:=TRUE;
		FOR nForCounter:=1 TO nNumMovers DO
			bAllDone:=bAllDone AND MoverFeedback[nForCounter].Done;
		END_FOR
		
		IF bAllDone THEN
			nCase := 60;
		END_IF

	//55:

	60:
		FOR nForCounter:=1 TO  nNumMovers DO
			IF nForCounter <= 9 THEN
				fbPlanarXtsMover[nForCounter].JoinTrack(MoverFeedback[nForCounter], GVL_Mc3.MC_Tracks[E_TrackNum.Big]);//   Mover[nForCounter].MoverTrackNr]);
			ELSE
				fbPlanarXtsMover[nForCounter].JoinTrack(MoverFeedback[nForCounter], GVL_Mc3.MC_Tracks[E_TrackNum.Main]);
			END_IF	
		END_FOR
		
		nCase := 70;
		
		
	70:
		bAllDone:=TRUE;
		FOR nForCounter:=1 TO nNumMovers DO
			bAllDone:=bAllDone AND MoverFeedback[nForCounter].Done;
		END_FOR
		
		IF bAllDone THEN
			nCase := 80;
		END_IF
		
	80:	
		FOR nForCounter:=1 TO nNumMovers DO
			nMoveState[nForCounter] := 0;
			aMoveOnTrackOptions[nForCounter].direction := MC_Direction.mcDirectionPositive;
			aMoveOnTrackOptions[nForCounter].gapMode := MC_GAP_MODE_ON_TRACK.Fast1D;
		END_FOR
		
		nCase := 100;

	100:	
		
		FOR nForCounter:=1 TO nNumMovers DO
			aDynamics[nForCounter].SetValuesVADJ(V := stMoverConfig.NormalVelo, A := stMoverConfig.NormalAccel, D := stMoverConfig.NormalDecel, J := stMoverConfig.NormalJerk);
			aMoveOnTrackOptions[nForCounter].gap:= stMoverConfig.MoverGap;
		END_FOR
		//Adjust the first mover parameters to induce a platoon
		aDynamics[GC.nNumMinMovers].SetValuesVADJ(V := stMoverConfig.NormalVelo-stMoverConfig.VeloComp, A := stMoverConfig.NormalAccel, D := stMoverConfig.NormalDecel, J := stMoverConfig.NormalJerk);

		FOR nForCounter:=1 TO nNumMovers DO
			CASE nMoveState[nForCounter] OF
				
				0: // Track 3 Main Cycle
					fbPlanarXtsMover[nForCounter].McPlanarMover.MoveOnTrack(commandFeedback := MoverFeedback[nForCounter],
																		targetTrack := GVL_Mc3.MC_Tracks[E_TrackNum.Main],
																		targetPositionOnTrack := GVL_Mc3.MC_Tracks[E_TrackNum.Main].GetLength()-stTrackGlobalConfig.TargetPosnBeforeTrackEnd,
																		constraint := aDynamics[nForCounter],
																		options := aMoveOnTrackOptions[nForCounter]);
					nMoveState[nForCounter] := 10;
					
				10: //Mover reaches Magnet Trigger Point; 
					IF TrackSectors[nForCounter].afbSector[GC.MAG_TRIG_SECTOR_OPART_PRE].stTrackSectorStatus.MoverEnteredSector.Q THEN
							IF (TrackSectors[nForCounter].afbSector[GC.SHORTCUT_ENTRY_HALF_IPART].stTrackSectorStatus.MoverCountOnSector < 
								GVL_General.stSwitchConfig.SwitchModeInternal.MaxMoverCountShortcut) THEN
							//	GVL_General.stSwitchConfig.SwitchModeInternal.ShuttleCountToDivert		:= stSwitchConfig.SwitchModeInternal.ShuttleCountToDivert -1;
								 fbPlanarXtsMover[nForCounter].P_CmdDivert := TRUE;
							ELSE
								 fbPlanarXtsMover[nForCounter].P_CmdDivert := FALSE;
							END_IF
							nMoveState[nForCounter] := 20;
					END_IF

					
				20: //Decision state to route mover through the switch or continue on the outer loop
					IF fbPlanarXtsMover[nForCounter].P_CmdDivert THEN
						IF SwitchMagnet.MagnetOn THEN
							nMoveState[nForCounter]				:= 50;	// 40- SmallLoop
						END_IF
					ELSE
							nMoveState[nForCounter]     	:= 30;	// 40- SmallLoop
					END_IF
        		 	
				30: //Move command to continue straight
					fbPlanarXtsMover[nForCounter].McPlanarMover.MoveOnTrack(commandFeedback := MoverFeedback[nForCounter],
																		targetTrack := GVL_Mc3.MC_Tracks[E_TrackNum.Big],
																		targetPositionOnTrack := GVL_Mc3.MC_Tracks[E_TrackNum.Big].GetLength()-stTrackGlobalConfig.TargetPosnBeforeTrackEnd,
																		constraint := aDynamics[nForCounter],
																		options := aMoveOnTrackOptions[nForCounter]);		
					nMoveState[nForCounter] := 40;
				
					
				40:
					IF TrackSectors[nForCounter].afbSector[GC.NO_DIVERT_POST_MAG].stTrackSectorStatus.MoverExitedSector.Q THEN
						nMoveState[nForCounter]     := 0;
					END_IF				
				
			
				50: // Route through shortcut
					fbPlanarXtsMover[nForCounter].McPlanarMover.MoveOnTrack(commandFeedback := MoverFeedback[nForCounter],
																		targetTrack := GVL_Mc3.MC_Tracks[E_TrackNum.Small],
																		targetPositionOnTrack := GVL_Mc3.MC_Tracks[E_TrackNum.Small].GetLength()-stTrackGlobalConfig.TargetPosnBeforeTrackEnd,
																		constraint := aDynamics[nForCounter],
																		options := aMoveOnTrackOptions[nForCounter]);
					nMoveState[nForCounter] := 60;
			
				60:
					IF stTrackShortcutConfig.TestPowerMat THEN
						nMoveState[nForCounter] := 70;
					ELSE
						nMoveState[nForCounter] := 0;	
					END_IF
					
				80:
					GVL_Mc3.fbPlanarXtsMover[nForCounter].McPlanarMover.MoveOnTrack(commandFeedback := MoverFeedback[nForCounter],
																		targetTrack := GVL_Mc3.MC_Tracks[E_TrackNum.Main],
																		targetPositionOnTrack := stTrackGlobalConfig.StopPos,
																		constraint := aDynamics[nForCounter],
																		options := aMoveOnTrackOptions[nForCounter]);					

					nMoveState[nForCounter] := 90;
				90:
					IF MoverFeedback[nForCounter].Done THEN
						StartTimer[nForCounter] := TRUE;
						nMoveState[nForCounter] := 95;
					END_IF
					
				95:
					IF 	StopTimer[nForCounter].Q THEN
						StartTimer[nForCounter] := FALSE;
						nMoveState[nForCounter] := 0;	
					END_IF
				END_CASE
		
		END_FOR

		IF bStopSequence AND NOT(IsMoverInBlockingArea) THEN
			nCase := 110;
			bStopSequence := FALSE;
		END_IF
		110:
			N:= nNumMovers;
			FOR nForCounter:=1 TO nNumMovers DO		
				GVL_General.aStopPositions[nForCounter] := TO_LREAL(  fbXtsEnvironment.XpuTcIo(1).MoverTcIo(TO_UINT(N)).GetSimulatedStartUpPosition());
				N := N -1;
			END_FOR
			nCase := 120;
		
		120:	
			nActStopPos := UDINT_TO_UINT(GC.nNumMaxMovers-nNumMovers+1);
			FOR nForCounter:=1 TO nNumMovers DO
				aDynamics[nForCounter].SetValuesVADJ(V := stMoverConfig.StoppingVelo, A := stMoverConfig.NormalAccel, D := stMoverConfig.NormalDecel, J := stMoverConfig.NormalJerk);
				nMoveState[nForCounter] := 0;
				fbPlanarXtsMover[nForCounter].McPlanarMover.MoveOnTrack(MoverFeedback[nForCounter], GVL_Mc3.MC_Tracks[E_TrackNum.Main], 300, aDynamics[nForCounter],aMoveOnTrackOptions[nForCounter]);
			END_FOR

			nCase:= 130; 
		130:
			FOR nForCounter:=1 TO GC.nNumMaxMovers - (nNumMovers-GC.nNumMaxMovers)  DO
				CASE nMoveState[nForCounter] OF
					0:								
						
						IF GVL_Mc3.fbPlanarXtsMover[nForCounter].P_PlanarMover.MoverPos < 300 AND GVL_Mc3.fbPlanarXtsMover[nForCounter].P_PlanarMover.TrackID = GVL_Mc3.MC_Tracks[E_TrackNum.main].MCTOPLC_STD.TrackOID THEN
							aMoveOnTrackOptions[nForCounter].gap:= 150;
							fbPlanarXtsMover[nForCounter].McPlanarMover.MoveOnTrack(commandFeedback := MoverFeedback[nForCounter],
																				targetTrack := GVL_Mc3.MC_Tracks[E_TrackNum.Main],
																				targetPositionOnTrack := aStopPositions[nActStopPos],
																				constraint := aDynamics[nForCounter],
																				options := aMoveOnTrackOptions[nForCounter]);									
							nActStopPos := nActStopPos + 1;
							nMoveState[nForCounter] := 10;
						END_IF
				END_CASE
			END_FOR
		
			bAllDone := TRUE;
			FOR nForCounter:=1 TO nNumMovers DO
				IF NOT(MoverFeedback[nForCounter].Done OR MoverFeedback[nForCounter].Error) THEN
					bAllDone := FALSE;
					EXIT;
				END_IF
			END_FOR
			
			IF bAllDone THEN
				nCase := 150;
			END_IF
		
		140:
			FOR nForCounter:=1 TO nNumMovers DO
				fbPlanarXtsMover[nForCounter].McPlanarMover.Halt(MoverFeedback[nForCounter], aDynamics[nForCounter]);
			END_FOR	
			
			nCase := 145;
			
		145:
			bAllDone := TRUE;
			FOR nForCounter:=1 TO nNumMovers DO
				IF NOT(MoverFeedback[nForCounter].Done OR MoverFeedback[nForCounter].Error) THEN
					bAllDone := FALSE;
					EXIT;
				END_IF
			END_FOR
			
			IF bAllDone THEN
				nCase := 150;
			END_IF
		
		//Disable
		150:
			FOR nForCounter:=1 TO nNumMovers DO
				fbPlanarXtsMover[nForCounter].McPlanarMover.Disable(MoverFeedback[nForCounter]);
			END_FOR
				
			nCase := 0;
END_CASE

IF stSwitchConfig.ModeChangeInMotionOK THEN
    stSwitchConfig.SwitchModeInternal		:= 						stSwitchConfig.SwitchModeHMI;
END_IF
MagnetEnabled  := MoverStop (* SafetyOK *) AND NOT Fault;

SwitchMagnet(stSwitchConfig := GVL_General.stSwitchConfig, 
				ShuttleVelocity := GVL_General.stMoverConfig.NormalVelo, 
				Command := bCmdMagnetOn);

FOR nForCounter:=1 TO nNumMovers DO
    //Only enable Magnet if DivertQueue = 0
    {warning <'Adjust Multi Sector for Only Into Shortcut?'>}
    stSwitchConfig.ModeChangeInMotionOK := NOT TrackSectors[nForCounter].ShortcutEntrySectorStatus.MoverIsOnSector;

		// Execute command to magnet for divert
	IF MagnetEnabled AND fbPlanarXtsMover[nForCounter].P_CmdDivert THEN
			bCmdMagnetOn := TrackSectors[nForCounter].SingularSectorStatus[GC.MAG_ON_SECTOR_OTRACK].MoverIsOnSector;
	ELSIF NOT MagnetEnabled OR TrackSectors[nForCounter].SingularSectorStatus[GC.MAG_ON_SECTOR_OTRACK].MoverExitedSector.Q THEN
		fbPlanarXtsMover[nForCounter].P_CmdDivert	:= FALSE;
		bCmdMagnetOn 															:= FALSE;
	END_IF

	GVL_Mc3.TrackSectors[nForCounter](MoverIndex := nForCounter);

	fbPlanarXtsMover[nForCounter]();
END_FOR

pwm();

FP_Counter(CLK := bCmdMagnetOn);

IF FP_Counter.Q THEN
	Switchcounter := Switchcounter+1;
END_IF]]></ST>
    </Implementation>
    <Method Name="M_WritePlanarTrackConfig" Id="{0295121c-55f9-0613-05f6-3ba76e5df670}">
      <Declaration><![CDATA[METHOD M_WritePlanarTrackConfig]]></Declaration>
      <Implementation>
        <ST><![CDATA[stPlanarTrackConfig[E_TrackNum.Big].MCTrack				:= GVL_Mc3.MC_Tracks[E_TrackNum.Big].MCTOPLC_STD;
stPlanarTrackConfig[E_TrackNum.Small].MCTrack			:= GVL_Mc3.MC_Tracks[E_TrackNum.Small].MCTOPLC_STD;
stPlanarTrackConfig[E_TrackNum.Main].MCTrack			:= GVL_Mc3.MC_Tracks[E_TrackNum.Main].MCTOPLC_STD;
                                                    	
stPlanarTrackConfig[E_TrackNum.Big].TrackIndex			:= E_TrackNum.Big;
stPlanarTrackConfig[E_TrackNum.Small].TrackIndex		:= E_TrackNum.Small;
stPlanarTrackConfig[E_TrackNum.Main].TrackIndex			:= E_TrackNum.Main;]]></ST>
      </Implementation>
    </Method>
  </POU>
</TcPlcObject>