<?xml version="1.0" encoding="utf-8"?>
<TcPlcObject Version="1.1.0.1">
  <POU Name="FB_AllTrackSectors" Id="{8170c47e-844a-0729-0ada-578a428ea257}" SpecialFunc="None">
    <Declaration><![CDATA[FUNCTION_BLOCK FB_AllTrackSectors
VAR_INPUT
			TrackSectorsRef				: REFERENCE TO ARRAY[GC.nNumMinMovers..GC.nNumMaxMovers] OF FB_TrackSectors;
END_VAR
//VAR_IN_OUT CONSTANT //not writeable by this FB
//		TrackSectorsRef				: ARRAY[*] OF FB_TrackSectors;
//END_VAR
VAR_OUTPUT
END_VAR
VAR
	MoverIndex			: UDINT;
	ForCounterExit : ARRAY[GC.MIN_SECTOR_CT..GC.MAX_SECTOR_CT] OF UDINT;
	SectorIndex : UDINT;
	AllSectorStatus	: ARRAY[GC.nNumMinMovers..GC.nNumMaxMovers] OF ARRAY[GC.MIN_SECTOR_CT..GC.MAX_SECTOR_CT] OF ST_StaticSectorStatus;
	LowerOut : DINT;
	UpperOut : DINT;
	AMoverIsOnSector	: ARRAY[GC.MIN_SECTOR_CT..GC.MAX_SECTOR_CT] OF BOOL;
	LapTrig1		: ST_MergeWindow;
	LapGap			: ST_MergeWindow;
	WindowClearDebounce : TIME;
	GapClearTail			: Tc2_Standard.TON;
	ValidPosnTime				: ST_PosnTime;
	MoverIdToFollowOnMerge	: UDINT;
END_VAR]]></Declaration>
    <Implementation>
      <ST><![CDATA[//LowerOut := LOWER_BOUND(TrackSectorsRef, 1);
//UpperOut := UPPER_BOUND(TrackSectorsRef, 1);

//IF LowerOut<>0 AND UpperOut<>0 THEN
	_M_EvaluateStatus();
//END_IF]]></ST>
    </Implementation>
    <Method Name="_M_EvaluateStatus" Id="{cdab348b-40a1-098a-037b-f73262f9331f}">
      <Declaration><![CDATA[METHOD PRIVATE _M_EvaluateStatus]]></Declaration>
      <Implementation>
        <ST><![CDATA[IF ADR(TrackSectorsRef) <> 0 THEN // pointer validity check
	FOR MoverIndex := GC.nNumMinMovers TO GVL_General.nNumMovers BY 1 DO
		FOR SectorIndex := GC.MIN_SECTOR_CT TO GC.MAX_SECTOR_CT BY 1 DO
			//Note!: VAR_IN_OUT (REF) Arrays are O-Based! 
			AllSectorStatus[MoverIndex][SectorIndex] := TrackSectorsRef[(MoverIndex)].SectorStatus[(SectorIndex)];
			
			IF LapTrig1.Latch AND_THEN TrackSectorsRef[MoverIndex].SectorStatus[GC.OUTER_FINISH_MOVERTOFOLLOW].MoverIsOnSector THEN
				MoverIdToFollowOnMerge	:= MoverIndex;
			END_IF
	
		END_FOR
	END_FOR
END_IF

//Merge Upstream Pre
FOR ForCounterExit[GC.OUTER_MERGE_UPSTREAM_PRE] := GC.nNumMinMovers TO GVL_General.nNumMovers BY 1 DO
	IF AllSectorStatus[ForCounterExit[GC.OUTER_MERGE_UPSTREAM_PRE]][GC.OUTER_MERGE_UPSTREAM_PRE].MoverIsOnSector THEN
			AMoverIsOnSector[GC.OUTER_MERGE_UPSTREAM_PRE] := TRUE;
			EXIT;
		ELSIF NOT AllSectorStatus[ForCounterExit[GC.OUTER_MERGE_UPSTREAM_PRE]][GC.OUTER_MERGE_UPSTREAM_PRE].MoverIsOnSector THEN
			AMoverIsOnSector[GC.OUTER_MERGE_UPSTREAM_PRE] := FALSE;
		END_IF
END_FOR

//Merge Upstream
FOR ForCounterExit[GC.OUTER_MERGE_UPSTREAM] := GC.nNumMinMovers TO GVL_General.nNumMovers BY 1 DO
	IF AllSectorStatus[ForCounterExit[GC.OUTER_MERGE_UPSTREAM]][GC.OUTER_MERGE_UPSTREAM].MoverIsOnSector THEN
			AMoverIsOnSector[GC.OUTER_MERGE_UPSTREAM] := TRUE;
			EXIT;
		ELSIF NOT AllSectorStatus[ForCounterExit[GC.OUTER_MERGE_UPSTREAM]][GC.OUTER_MERGE_UPSTREAM].MoverIsOnSector THEN
			AMoverIsOnSector[GC.OUTER_MERGE_UPSTREAM] := FALSE;
		END_IF
END_FOR

//Merge Downstream
FOR ForCounterExit[GC.OUTER_MERGE_DOWNSTREAM] := GC.nNumMinMovers TO GVL_General.nNumMovers BY 1 DO
	IF AllSectorStatus[ForCounterExit[GC.OUTER_MERGE_DOWNSTREAM]][GC.OUTER_MERGE_DOWNSTREAM].MoverIsOnSector THEN
			AMoverIsOnSector[GC.OUTER_MERGE_DOWNSTREAM] := TRUE;
			EXIT;
		ELSIF NOT AllSectorStatus[ForCounterExit[GC.OUTER_MERGE_DOWNSTREAM]][GC.OUTER_MERGE_DOWNSTREAM].MoverIsOnSector THEN
			AMoverIsOnSector[GC.OUTER_MERGE_DOWNSTREAM] := FALSE;
		END_IF
END_FOR

//Merge Combined
FOR ForCounterExit[GC.OUTER_MERGE_COMBINED] := GC.nNumMinMovers TO GVL_General.nNumMovers BY 1 DO
	IF AllSectorStatus[ForCounterExit[GC.OUTER_MERGE_COMBINED]][GC.OUTER_MERGE_COMBINED].MoverIsOnSector THEN
			AMoverIsOnSector[GC.OUTER_MERGE_COMBINED] := TRUE;
			EXIT;
		ELSIF NOT AllSectorStatus[ForCounterExit[GC.OUTER_MERGE_COMBINED]][GC.OUTER_MERGE_COMBINED].MoverIsOnSector THEN
			AMoverIsOnSector[GC.OUTER_MERGE_COMBINED] := FALSE;
		END_IF
END_FOR

//Lap Trig 1
FOR ForCounterExit[GC.OUTER_FINISH_LAPTRIG] := GC.nNumMinMovers TO GVL_General.nNumMovers BY 1 DO
//		IF AllSectorStatus[ForCounterExit[GC.OUTER_FINISH_LAPTRIG1]][GC.OUTER_FINISH_LAPTRIG1].MoverIsOnSector THEN
//			AMoverIsOnSector[GC.OUTER_FINISH_LAPTRIG1] := TRUE;
//			EXIT;
//		ELSIF NOT AllSectorStatus[ForCounterExit[GC.OUTER_FINISH_LAPTRIG1]][GC.OUTER_FINISH_LAPTRIG1].MoverIsOnSector THEN
//			AMoverIsOnSector[GC.OUTER_FINISH_LAPTRIG1] := FALSE;
//		END_IF
	IF NOT LapTrig1.Latch AND NOT LapGap.Latch AND AllSectorStatus[ForCounterExit[GC.OUTER_FINISH_LAPTRIG]][GC.OUTER_FINISH_LAPTRIG].MoverExitedSector.Q THEN
			LapTrig1.Latch := TRUE;
			GapClearTail.IN	:= TRUE;
			LapTrig1.timestamp	:= Tc2_System.F_GetSystemTime();
			EXIT;
		END_IF
	IF LapTrig1.Latch AND NOT LapGap.Latch AND AllSectorStatus[ForCounterExit[GC.OUTER_FINISH_LAPTRIG]][GC.OUTER_FINISH_LAPTRIG].MoverEnteredSector.Q THEN
			LapGap.Latch := TRUE;
			LapGap.timestamp	:= Tc2_System.F_GetSystemTime();
			EXIT;
		END_IF
		
END_FOR

//Lap Trig 2
//FOR ForCounterExit[GC.OUTER_FINISH_LAPTRIG2] := GC.nNumMinMovers TO GVL_General.nNumMovers BY 1 DO
//		IF AllSectorStatus[ForCounterExit[GC.OUTER_FINISH_LAPTRIG2]][GC.OUTER_FINISH_LAPTRIG2].MoverIsOnSector THEN
//			AMoverIsOnSector[GC.OUTER_FINISH_LAPTRIG2] := TRUE;
//			EXIT;
//		ELSIF NOT AllSectorStatus[ForCounterExit[GC.OUTER_FINISH_LAPTRIG2]][GC.OUTER_FINISH_LAPTRIG2].MoverIsOnSector THEN
//			AMoverIsOnSector[GC.OUTER_FINISH_LAPTRIG2] := FALSE;
//		END_IF
//	IF LapTrig1.Latch AND NOT LapTrig2.Latch AND_THEN AllSectorStatus[ForCounterExit[GC.OUTER_FINISH_LAPTRIG2]][GC.OUTER_FINISH_LAPTRIG2].MoverEnteredSector.Q THEN
//			LapTrig2.Latch := TRUE;
//			EXIT;
//		END_IF
//END_FOR

_M_EvaluateWindow();

GapClearTail(PT := WindowClearDebounce);]]></ST>
      </Implementation>
    </Method>
    <Method Name="_M_EvaluateWindow" Id="{70d44e2b-75f6-0653-032e-9e64a1433a4c}">
      <Declaration><![CDATA[METHOD PRIVATE _M_EvaluateWindow
VAR_INST
//	TimeDeltaTemp 	: ULINT;
//	TimeDelta				: LREAL;
TrigAdd : BOOL;
TrigRem : BOOL;
	DistanceDeltaFromMerge : LREAL;
	TempCalc : LREAL;
	TargetTimeForLastTPosnAtMerge : ULINT;
END_VAR
]]></Declaration>
      <Implementation>
        <ST><![CDATA[IF (stMoverConfig.NormalVelo - stMoverConfig.VeloComp) <> 0 THEN
	WindowClearDebounce := LREAL_TO_TIME(1000*stTrackGlobalConfig.WindowLength / (stMoverConfig.NormalVelo - stMoverConfig.VeloComp));
END_IF

IF LapTrig1.Latch AND LapGap.Latch THEN
//	TimeDeltaTemp	:= LapGap.timestamp - LapTrig1.timestamp;
//	TimeDelta := ULINT_TO_REAL(TimeDeltaTemp) / TicksPerS;

	LapTrig1.Latch := FALSE;
	LapGap.Latch := FALSE;
	GapClearTail.IN	:= FALSE;

END_IF

IF GapClearTail.Q AND NOT LapGap.Latch THEN
	// Position to match with merging mover
	ValidPosnTime.ValidPosnSrc :=
			 TrackSectorsRef[GC.nNumMinMovers].P_SectorConfig[GC.OUTER_FINISH_LAPTRIG].PartSectorStartPosn - (stTrackGlobalConfig.WindowLength / 2);
	ValidPosnTime.ValidPosnSrcTime := LapTrig1.timestamp;
	MergeQueue.AddObjToBuffer(RefObject := ValidPosnTime.ValidPosnSrcTime);
	GapClearTail.IN	:= FALSE;
END_IF

DistanceDeltaFromMerge := GVL_Mc3.MC_Tracks[E_TrackNum.Big].GetLength() - ValidPosnTime.ValidPosnSrc;
IF (stMoverConfig.NormalVelo - stMoverConfig.VeloComp) <> 0 THEN 
	TempCalc 	:= 1000* (DistanceDeltaFromMerge / (stMoverConfig.NormalVelo - stMoverConfig.VeloComp));
END_IF
TargetTimeForLastTPosnAtMerge	:= MergeQueue.P_LastObjectRemoved + LREAL_TO_ULINT(TempCalc * 1E4);  //ms to count of 100ns intervals

//ValidPosnTime.ValidTargetDestTime := MergeQueue.P_LastObjectRemoved + ;

IF TrigRem THEN
	TrigRem	:= FALSE;
	MergeQueue.RemoveObjFromBuffer();
END_IF

IF TrigAdd THEN
	TrigAdd	:= FALSE;
	MergeQueue.AddObjToBuffer(RefObject := ValidPosnTime.ValidPosnSrcTime);	
END_IF

//Make a dynamic sector that follows the "virtual" position; could be used as a PermIntlk for violation of the sector by a real mover;]]></ST>
      </Implementation>
    </Method>
    <Method Name="_M_VARINOUT_TroubleshootingJunk" Id="{ea69075c-a9ec-0830-0636-202b848c0db0}">
      <Declaration><![CDATA[METHOD PRIVATE _M_VARINOUT_TroubleshootingJunk
VAR_INPUT
END_VAR
]]></Declaration>
      <Implementation>
        <ST><![CDATA[//IF ADR(TrackSectorsRef) <> 0 THEN
//	FOR MoverIndex := LowerOut TO UpperOut BY 1 DO

//AllSectorStatus[1][GC.OUTER_MERGE_COMBINED] 				:= TrackSectorsRef[1].SectorStatus[(GC.OUTER_MERGE_COMBINED)].MoverIsOnSector;
//AllSectorStatus[2][GC.OUTER_MERGE_COMBINED] 				:= TrackSectorsRef[2].SectorStatus[(GC.OUTER_MERGE_COMBINED)].MoverIsOnSector;
//AllSectorStatus[3][GC.OUTER_MERGE_COMBINED] 				:= TrackSectorsRef[3].SectorStatus[(GC.OUTER_MERGE_COMBINED)].MoverIsOnSector;
//AllSectorStatus[4][GC.OUTER_MERGE_COMBINED] 				:= TrackSectorsRef[4].SectorStatus[(GC.OUTER_MERGE_COMBINED)].MoverIsOnSector;
//AllSectorStatus[5][GC.OUTER_MERGE_COMBINED] 				:= TrackSectorsRef[5].SectorStatus[(GC.OUTER_MERGE_COMBINED)].MoverIsOnSector;
//AllSectorStatus[6][GC.OUTER_MERGE_COMBINED] 				:= TrackSectorsRef[6].SectorStatus[(GC.OUTER_MERGE_COMBINED)].MoverIsOnSector;
//AllSectorStatus[7][GC.OUTER_MERGE_COMBINED] 				:= TrackSectorsRef[7].SectorStatus[(GC.OUTER_MERGE_COMBINED)].MoverIsOnSector;
//AllSectorStatus[8][GC.OUTER_MERGE_COMBINED] 				:= TrackSectorsRef[8].SectorStatus[(GC.OUTER_MERGE_COMBINED)].MoverIsOnSector;
//AllSectorStatus[9][GC.OUTER_MERGE_COMBINED] 				:= TrackSectorsRef[9].SectorStatus[(GC.OUTER_MERGE_COMBINED)].MoverIsOnSector;
//AllSectorStatus[10][GC.OUTER_MERGE_COMBINED] 				:= TrackSectorsRef[10].SectorStatus[(GC.OUTER_MERGE_COMBINED)].MoverIsOnSector;
//AllSectorStatus[11][GC.OUTER_MERGE_COMBINED]				:= TrackSectorsRef[11].SectorStatus[(GC.OUTER_MERGE_COMBINED)].MoverIsOnSector;
//AllSectorStatus[12][GC.OUTER_MERGE_COMBINED]				:= TrackSectorsRef[12].SectorStatus[(GC.OUTER_MERGE_COMBINED)].MoverIsOnSector;
//AllSectorStatus[13][GC.OUTER_MERGE_COMBINED]				:= TrackSectorsRef[13].SectorStatus[(GC.OUTER_MERGE_COMBINED)].MoverIsOnSector;
//AllSectorStatus[14][GC.OUTER_MERGE_COMBINED]				:= TrackSectorsRef[14].SectorStatus[(GC.OUTER_MERGE_COMBINED)].MoverIsOnSector;
//AllSectorStatus[15][GC.OUTER_MERGE_COMBINED]				:= TrackSectorsRef[15].SectorStatus[(GC.OUTER_MERGE_COMBINED)].MoverIsOnSector;
//AllSectorStatus[16][GC.OUTER_MERGE_COMBINED] 				:= TrackSectorsRef[16].SectorStatus[(GC.OUTER_MERGE_COMBINED)].MoverIsOnSector;
//	END_FOR
//END_IF]]></ST>
      </Implementation>
    </Method>
    <Property Name="P_AMoverIsOnSector" Id="{aa8e3eac-0684-095a-1a33-a2f73cae8290}">
      <Declaration><![CDATA[PROPERTY P_AMoverIsOnSector : REFERENCE TO ARRAY[GC.MIN_SECTOR_CT..GC.MAX_SECTOR_CT] OF BOOL]]></Declaration>
      <Get Name="Get" Id="{0efc0011-49e0-0380-1773-49873cefbadf}">
        <Declaration><![CDATA[VAR
END_VAR
]]></Declaration>
        <Implementation>
          <ST><![CDATA[P_AMoverIsOnSector REF= AMoverIsOnSector;]]></ST>
        </Implementation>
      </Get>
    </Property>
  </POU>
</TcPlcObject>