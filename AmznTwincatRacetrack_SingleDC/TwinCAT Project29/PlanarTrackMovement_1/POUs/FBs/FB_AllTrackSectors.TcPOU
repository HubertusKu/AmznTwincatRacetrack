<?xml version="1.0" encoding="utf-8"?>
<TcPlcObject Version="1.1.0.1">
  <POU Name="FB_AllTrackSectors" Id="{8170c47e-844a-0729-0ada-578a428ea257}" SpecialFunc="None">
    <Declaration><![CDATA[FUNCTION_BLOCK FB_AllTrackSectors
VAR_INPUT
	TrackSectorsRef				: REFERENCE TO ARRAY[GC.nNumMinMovers..GC.nNumMaxMovers] OF FB_TrackSectors;
	HeadTrackSectorsRef		: REFERENCE TO ARRAY[GC.nNumMinMovers..GC.nNumMaxMovers] OF FB_TrackSectors;
	TailTrackSectorsRef		: REFERENCE TO ARRAY[GC.nNumMinMovers..GC.nNumMaxMovers] OF FB_TrackSectors;		
END_VAR
//VAR_IN_OUT CONSTANT //not writeable by this FB
//		TrackSectorsRef				: ARRAY[*] OF FB_TrackSectors;
//END_VAR
VAR
	DynamicMergeEvaluation : BOOL;
	MoverIndex			: UDINT;
	ForCounterExit : ARRAY[GC.MIN_TRACKSECTORS_REF..GC.MAX_TRACKSECTORS_REF] OF ARRAY[GC.MIN_SECTOR_CT..GC.MAX_SECTOR_CT] OF UDINT; // 1 to 3 are normal, Head, Tail TrackSectorsRef
	SectorIndex : UDINT;
	AllRealSectorStatus	: ARRAY[GC.nNumMinMovers..GC.nNumMaxMovers] OF ARRAY[GC.MIN_SECTOR_CT..GC.MAX_SECTOR_CT] OF ST_StaticSectorStatus;
	AllHeadSectorStatus : ARRAY[GC.nNumMinMovers..GC.nNumMaxMovers] OF ARRAY[GC.MIN_SECTOR_CT..GC.MAX_SECTOR_CT] OF ST_StaticSectorStatus;
	AllTailSectorStatus : ARRAY[GC.nNumMinMovers..GC.nNumMaxMovers] OF ARRAY[GC.MIN_SECTOR_CT..GC.MAX_SECTOR_CT] OF ST_StaticSectorStatus;
	LowerOut : DINT;
	UpperOut : DINT;
	RealMoverIsOnSector	: ARRAY[GC.MIN_SECTOR_CT..GC.MAX_SECTOR_CT] OF BOOL;
	ValidMerge				: RingBuffer.ST_MoverMerge;
	TempMerge					: RingBuffer.ST_MoverMerge;
	MoverIdMergeOnSector		: UDINT;
	MoverInDecelSector			: BOOL;
	TimeForShortcutMergingMover : LREAL;
	ValidMergeTrig				: BOOL;
END_VAR]]></Declaration>
    <Implementation>
      <ST><![CDATA[//LowerOut := LOWER_BOUND(TrackSectorsRef, 1);
//UpperOut := UPPER_BOUND(TrackSectorsRef, 1);

//IF LowerOut<>0 AND UpperOut<>0 THEN
	_M_EvaluateStatus();
//END_IF]]></ST>
    </Implementation>
    <Method Name="_M_BufferValidMergeRefs" Id="{3fb3bb7a-b125-0ba7-003e-4d7d398ed301}">
      <Declaration><![CDATA[METHOD _M_BufferValidMergeRefs
VAR_INST
	RealMoverEnteredSector : Tc2_Standard.R_TRIG;
END_VAR]]></Declaration>
      <Implementation>
        <ST><![CDATA[//Merge - 'If Any'
FOR ForCounterExit[GC.TRACK_SECTORS_REG][GC.OUTER_SHORTCUT_PROJECTION] := GC.nNumMinMovers TO GVL_General.nNumMovers BY 1 DO
	IF AllRealSectorStatus[ForCounterExit[GC.TRACK_SECTORS_REG][GC.OUTER_SHORTCUT_PROJECTION]][GC.OUTER_SHORTCUT_PROJECTION].MoverIsOnSector THEN
			RealMoverIsOnSector[GC.OUTER_SHORTCUT_PROJECTION] := TRUE;
			EXIT;
		ELSIF NOT AllRealSectorStatus[ForCounterExit[GC.TRACK_SECTORS_REG][GC.OUTER_SHORTCUT_PROJECTION]][GC.OUTER_SHORTCUT_PROJECTION].MoverIsOnSector THEN
			RealMoverIsOnSector[GC.OUTER_SHORTCUT_PROJECTION] := FALSE;
		END_IF
END_FOR

//Checking Expanded Movers against real mover locations
FOR ForCounterExit[GC.TRACK_SECTORS_HEAD][GC.OUTER_SHORTCUT_PROJECTION] := GC.nNumMinMovers TO GC.nNumMaxMovers DO
	IF NOT RealMoverIsOnSector[GC.OUTER_SHORTCUT_PROJECTION] THEN
		IF HeadTrackSectorsRef[ForCounterExit[GC.TRACK_SECTORS_HEAD][GC.OUTER_SHORTCUT_PROJECTION]].SectorStatus[GC.OUTER_SHORTCUT_PROJECTION].MoverEnteredSector.Q THEN 
			ValidMerge.MoverID 			:= ForCounterExit[GC.TRACK_SECTORS_HEAD][GC.OUTER_SHORTCUT_PROJECTION];
			ValidMerge.ExpMoverType 	:= E_ExpMover.Head;
			ValidMerge.MergeWindowStartPosn	:= HeadExpMovers[ForCounterExit[GC.TRACK_SECTORS_HEAD][GC.OUTER_SHORTCUT_PROJECTION]].P_ExpMoverStatus.XtsAdjustedData.fPartPosition;
		END_IF
	ELSIF RealMoverEnteredSector.Q OR HeadTrackSectorsRef[ValidMerge.MoverID].SectorStatus[GC.OUTER_SHORTCUT_PROJECTION].MoverExitedSector.Q THEN
		IF HeadTrackSectorsRef[ForCounterExit[GC.TRACK_SECTORS_HEAD][GC.OUTER_SHORTCUT_PROJECTION]].SectorStatus[GC.OUTER_SHORTCUT_PROJECTION].MoverIsOnSector THEN 
			ValidMerge.MoverID 			:= ForCounterExit[GC.TRACK_SECTORS_HEAD][GC.OUTER_SHORTCUT_PROJECTION];
			ValidMerge.ExpMoverType 	:= E_ExpMover.Head;
			ValidMerge.MergeWindowEndPosn	:= HeadExpMovers[ForCounterExit[GC.TRACK_SECTORS_HEAD][GC.OUTER_SHORTCUT_PROJECTION]].P_ExpMoverStatus.XtsAdjustedData.fPartPosition;
		END_IF
	END_IF
END_FOR

//FOR ForCounterExit[GC.TRACK_SECTORS_TAIL][GC.OUTER_SHORTCUT_PROJECTION] := GC.nNumMinMovers TO GC.nNumMaxMovers DO
//	IF NOT RealMoverIsOnSector[GC.OUTER_SHORTCUT_PROJECTION] THEN
//		IF TailTrackSectorsRef[ForCounterExit[GC.TRACK_SECTORS_TAIL][GC.OUTER_SHORTCUT_PROJECTION]].SectorStatus[GC.OUTER_SHORTCUT_PROJECTION].MoverExitedSector.Q THEN
//			ValidMerge.MoverID 			:= ForCounterExit[GC.TRACK_SECTORS_TAIL][GC.OUTER_SHORTCUT_PROJECTION];
//			ValidMerge.ExpMoverType 	:= E_ExpMover.Tail;
//			ValidMerge.MergeWindowEndPosn	:= TailExpMovers[ForCounterExit[GC.TRACK_SECTORS_TAIL][GC.OUTER_SHORTCUT_PROJECTION]].P_ExpMoverStatus.XtsAdjustedData.fPartPosition;
//		END_IF
//	END_IF
//END_FOR

IF ValidMergeTrig AND (ValidMerge.MoverID <> TempMerge.MoverID) AND (ValidMerge.ExpMoverType <> TempMerge.ExpMoverType) THEN
	TempMerge	:= ValidMerge;
	MergeQueue.AddObjToBuffer(RefObject := ValidMerge);
	ValidMergeTrig	:= FALSE;
END_IF


//Delete queue objects when they reach the merge position
//IF fbPlanarXtsMover[].P_XtsPositionInfo.fPartPosition = 

RealMoverEnteredSector(CLK := RealMoverIsOnSector[GC.OUTER_SHORTCUT_PROJECTION]);]]></ST>
      </Implementation>
    </Method>
    <Method Name="_M_CalculateTCompForMerge" Id="{34611b27-9299-0562-1fae-7552a25f6f25}">
      <Declaration><![CDATA[METHOD _M_CalculateTCompForMerge
]]></Declaration>
      <Implementation>
        <ST><![CDATA[//Calculate t if mover is between the start and end of this sector; this t is used to relate the constant velocity region on the outer loop
IF MoverIdMergeOnSector <> 0 THEN
	IF TrackSectorsRef[MoverIdMergeOnSector].SectorStatus[GC.SHORTCUT_MERGE_CALC_EXACT].MoverIsOnSector AND MoverInDecelSector THEN
		//This is only calculated for one mover at once
		TimeForShortcutMergingMover := F_t_SL2a(SectorLength := TrackSectorsRef[MoverIdMergeOnSector].SectorStatus[GC.SHORTCUT_MERGE_CALC_EXACT].MoverDistanceFromEnd, 
																						Acceleration := stMoverConfig.MaxDecel);
	END_IF
	
	IF TrackSectorsRef[MoverIdMergeOnSector].SectorStatus[GC.SHORTCUT_MERGE_CALC_EXACT].MoverExitedSector.Q AND MoverInDecelSector THEN
		MoverInDecelSector		:= FALSE;
	END_IF
END_IF]]></ST>
      </Implementation>
    </Method>
    <Method Name="_M_EvaluateStatus" Id="{cdab348b-40a1-098a-037b-f73262f9331f}">
      <Declaration><![CDATA[METHOD PRIVATE _M_EvaluateStatus]]></Declaration>
      <Implementation>
        <ST><![CDATA[IF ADR(TrackSectorsRef) <> 0 THEN // pointer validity check
	FOR MoverIndex := GC.nNumMinMovers TO GVL_General.nNumMovers BY 1 DO
		
	//Write All Sector Status
		FOR SectorIndex := GC.MIN_SECTOR_CT TO GC.MAX_SECTOR_CT BY 1 DO
			//Note!: VAR_IN_OUT (REF) Arrays are O-Based! 
			AllRealSectorStatus[MoverIndex][SectorIndex] := TrackSectorsRef[(MoverIndex)].SectorStatus[(SectorIndex)];
			AllHeadSectorStatus[MoverIndex][SectorIndex] := HeadTrackSectorsRef[(MoverIndex)].SectorStatus[(SectorIndex)];
			AllTailSectorStatus[MoverIndex][SectorIndex] := TailTrackSectorsRef[(MoverIndex)].SectorStatus[(SectorIndex)];
		END_FOR

		IF TrackSectorsRef[MoverIndex].SectorStatus[GC.SHORTCUT_MERGE_CALC_EXACT].MoverEnteredSector.Q AND NOT MoverInDecelSector THEN
			MoverIdMergeOnSector 	:= MoverIndex;
			MoverInDecelSector		:= TRUE;
		END_IF

	END_FOR
END_IF

IF NOT DynamicMergeEvaluation THEN
	_M_StaticSectorClear();
ELSE
	// // ELSIF Config.UseExpandedMovers
END_IF

//Do all this
_M_CalculateTCompForMerge();

_M_BufferValidMergeRefs();]]></ST>
      </Implementation>
    </Method>
    <Method Name="_M_StaticSectorClear" Id="{84bd337c-c2f6-0b56-0a3d-563d2eecfbb2}">
      <Declaration><![CDATA[METHOD PRIVATE _M_StaticSectorClear]]></Declaration>
      <Implementation>
        <ST><![CDATA[//Checking Expanded Movers against real mover locations; adding valid references to buffer
FOR ForCounterExit[GC.TRACK_SECTORS_REG][GC.OUTER_MERGE_COLLISION] := GC.nNumMinMovers TO GC.nNumMaxMovers DO
	IF AllRealSectorStatus[ForCounterExit[GC.TRACK_SECTORS_REG][GC.OUTER_MERGE_COLLISION]][GC.OUTER_MERGE_COLLISION].MoverIsOnSector THEN
			RealMoverIsOnSector[GC.OUTER_MERGE_COLLISION] := TRUE;
			EXIT;
		ELSIF NOT AllRealSectorStatus[ForCounterExit[GC.TRACK_SECTORS_REG][GC.OUTER_MERGE_COLLISION]][GC.OUTER_MERGE_COLLISION].MoverIsOnSector THEN
			RealMoverIsOnSector[GC.OUTER_MERGE_COLLISION] := FALSE;
		END_IF
END_FOR]]></ST>
      </Implementation>
    </Method>
    <Method Name="_M_VARINOUT_TroubleshootingJunk" Id="{ea69075c-a9ec-0830-0636-202b848c0db0}">
      <Declaration><![CDATA[METHOD PRIVATE _M_VARINOUT_TroubleshootingJunk
VAR_INPUT
END_VAR
]]></Declaration>
      <Implementation>
        <ST><![CDATA[//IF ADR(TrackSectorsRef) <> 0 THEN
//	FOR MoverIndex := LowerOut TO UpperOut BY 1 DO

//AllSectorStatus[1][GC.OUTER_MERGE_COMBINED] 				:= TrackSectorsRef[1].SectorStatus[(GC.OUTER_MERGE_COMBINED)].MoverIsOnSector;
//AllSectorStatus[2][GC.OUTER_MERGE_COMBINED] 				:= TrackSectorsRef[2].SectorStatus[(GC.OUTER_MERGE_COMBINED)].MoverIsOnSector;
//AllSectorStatus[3][GC.OUTER_MERGE_COMBINED] 				:= TrackSectorsRef[3].SectorStatus[(GC.OUTER_MERGE_COMBINED)].MoverIsOnSector;
//AllSectorStatus[4][GC.OUTER_MERGE_COMBINED] 				:= TrackSectorsRef[4].SectorStatus[(GC.OUTER_MERGE_COMBINED)].MoverIsOnSector;
//AllSectorStatus[5][GC.OUTER_MERGE_COMBINED] 				:= TrackSectorsRef[5].SectorStatus[(GC.OUTER_MERGE_COMBINED)].MoverIsOnSector;
//AllSectorStatus[6][GC.OUTER_MERGE_COMBINED] 				:= TrackSectorsRef[6].SectorStatus[(GC.OUTER_MERGE_COMBINED)].MoverIsOnSector;
//AllSectorStatus[7][GC.OUTER_MERGE_COMBINED] 				:= TrackSectorsRef[7].SectorStatus[(GC.OUTER_MERGE_COMBINED)].MoverIsOnSector;
//AllSectorStatus[8][GC.OUTER_MERGE_COMBINED] 				:= TrackSectorsRef[8].SectorStatus[(GC.OUTER_MERGE_COMBINED)].MoverIsOnSector;
//AllSectorStatus[9][GC.OUTER_MERGE_COMBINED] 				:= TrackSectorsRef[9].SectorStatus[(GC.OUTER_MERGE_COMBINED)].MoverIsOnSector;
//AllSectorStatus[10][GC.OUTER_MERGE_COMBINED] 				:= TrackSectorsRef[10].SectorStatus[(GC.OUTER_MERGE_COMBINED)].MoverIsOnSector;
//AllSectorStatus[11][GC.OUTER_MERGE_COMBINED]				:= TrackSectorsRef[11].SectorStatus[(GC.OUTER_MERGE_COMBINED)].MoverIsOnSector;
//AllSectorStatus[12][GC.OUTER_MERGE_COMBINED]				:= TrackSectorsRef[12].SectorStatus[(GC.OUTER_MERGE_COMBINED)].MoverIsOnSector;
//AllSectorStatus[13][GC.OUTER_MERGE_COMBINED]				:= TrackSectorsRef[13].SectorStatus[(GC.OUTER_MERGE_COMBINED)].MoverIsOnSector;
//AllSectorStatus[14][GC.OUTER_MERGE_COMBINED]				:= TrackSectorsRef[14].SectorStatus[(GC.OUTER_MERGE_COMBINED)].MoverIsOnSector;
//AllSectorStatus[15][GC.OUTER_MERGE_COMBINED]				:= TrackSectorsRef[15].SectorStatus[(GC.OUTER_MERGE_COMBINED)].MoverIsOnSector;
//AllSectorStatus[16][GC.OUTER_MERGE_COMBINED] 				:= TrackSectorsRef[16].SectorStatus[(GC.OUTER_MERGE_COMBINED)].MoverIsOnSector;
//	END_FOR
//END_IF]]></ST>
      </Implementation>
    </Method>
    <Property Name="P_AMoverIsOnSector" Id="{aa8e3eac-0684-095a-1a33-a2f73cae8290}">
      <Declaration><![CDATA[PROPERTY P_AMoverIsOnSector : REFERENCE TO ARRAY[GC.MIN_SECTOR_CT..GC.MAX_SECTOR_CT] OF BOOL]]></Declaration>
      <Get Name="Get" Id="{0efc0011-49e0-0380-1773-49873cefbadf}">
        <Declaration><![CDATA[VAR
END_VAR
]]></Declaration>
        <Implementation>
          <ST><![CDATA[P_AMoverIsOnSector REF= RealMoverIsOnSector;]]></ST>
        </Implementation>
      </Get>
    </Property>
  </POU>
</TcPlcObject>