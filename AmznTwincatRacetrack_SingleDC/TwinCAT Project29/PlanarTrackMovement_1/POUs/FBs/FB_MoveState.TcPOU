<?xml version="1.0" encoding="utf-8"?>
<TcPlcObject Version="1.1.0.1">
  <POU Name="FB_MoveState" Id="{8596ee9e-45b2-0b76-19d2-61380e3972f4}" SpecialFunc="None">
    <Declaration><![CDATA[FUNCTION_BLOCK FB_MoveState
VAR_INPUT
	fbPlanarXtsMover 	: REFERENCE TO FB_PlanarXtsMover;
	TrackSectors			: REFERENCE TO FB_TrackSectors;
END_VAR
VAR_OUTPUT
END_VAR
//Make Stateless
VAR
	nMoveState	: UDINT;
END_VAR]]></Declaration>
    <Implementation>
      <ST><![CDATA[//Make Stateless
M_EvaluateTrackTransition(DepartingTrackRef := E_TrackNum.Main, ArrivingTrackRef := E_TrackNum.Big, DepartPermissiveSectorRef := );

M_EvaluateTrackTransition(DepartingTrackRef := E_TrackNum.Big, ArrivingTrackRef := E_TrackNum.Main, DepartPermissiveSectorRef := );

M_EvaluateTrackTransition(DepartingTrackRef := E_TrackNum.Main, ArrivingTrackRef := E_TrackNum.Small, DepartPermissiveSectorRef := );

M_EvaluateTrackTransition(DepartingTrackRef := E_TrackNum.Small, ArrivingTrackRef := E_TrackNum.Main, DepartPermissiveSectorRef := );


CASE nMoveState OF
				
				0: // Start-up/Init
					IF fbPlanarXtsMover.P_MoverSort.TrackID = GVL_General.PlanarTrackOuterFinish THEN
						fbPlanarXtsMover.P_MC_PlanarMover.MoveOnTrack(commandFeedback := fbPlanarXtsMover.P_MoverFeedback,
																			targetTrack := GVL_Mc3.MC_Tracks[E_TrackNum.Big],
																			targetPositionOnTrack := GVL_Mc3.MC_Tracks[E_TrackNum.Big].GetLength()-stTrackGlobalConfig.TargetPosnBeforeTrackEnd,
																			constraint := fbPlanarXtsMover.P_Dynamics,
																			options := fbPlanarXtsMover.P_MoverOptions.BaseMoveOptions);
						 nMoveState 	:= 20;
					ELSIF (fbPlanarXtsMover.P_MoverSort.TrackID = GVL_General.PlanarTrackOuterStart) AND 
								fbPlanarXtsMover.P_XtsPositionInfo.fPartPosition < TrackSectors.P_SectorConfig[GC.DIVERTQ_SECTOR_OPART].PartSectorStartPosn THEN
						fbPlanarXtsMover.P_MC_PlanarMover.MoveOnTrack(commandFeedback := fbPlanarXtsMover.P_MoverFeedback,
																			targetTrack := GVL_Mc3.MC_Tracks[E_TrackNum.Main],
																			targetPositionOnTrack := GVL_Mc3.MC_Tracks[E_TrackNum.Main].GetLength()-stTrackGlobalConfig.TargetPosnBeforeTrackEnd,
																			constraint := fbPlanarXtsMover.P_Dynamics,
																			options := fbPlanarXtsMover.P_MoverOptions.BaseMoveOptions);
						 nMoveState 	:= 10;
					END_IF
					
				5: // In Recirc - from Big to Main Track - departing Gap Transition Zone - this Move command could be cyclic
					IF stPlcSystem.TempSysTime = 0 XOR stPlcSystem.TempSysTime = stPlcSystem.SysTime THEN
						stPlcSystem.TempSysTime := stPlcSystem.SysTime + (stPlcSystem.CfgIntervalExec * stPlcSystem.nCycleTime); //next valid clock to issue move command again
						fbPlanarXtsMover.P_eMerge		:= E_MergeType.NoMerge;
						fbPlanarXtsMover.P_MasterSyncId	:= 0;
						fbPlanarXtsMover.P_MasterSyncPosition	:= 0;
						fbPlanarXtsMover.P_MC_PlanarMover.MoveOnTrack(commandFeedback := fbPlanarXtsMover.P_MoverFeedback,
																		targetTrack := GVL_Mc3.MC_Tracks[E_TrackNum.Main],
																		targetPositionOnTrack := GVL_Mc3.MC_Tracks[E_TrackNum.Main].GetLength()-stTrackGlobalConfig.TargetPosnBeforeTrackEnd,
																		constraint := fbPlanarXtsMover.P_Dynamics, 
																		options := fbPlanarXtsMover.P_MoverOptions.BaseMoveOptions);
					END_IF
																		
					//Continuously call the above move command while GapInTransition TRUE (otherwise it's a one-shot command)
					IF NOT fbPlanarXtsMover.P_MoverOptions.GapInTransition THEN
						stPlcSystem.TempSysTime		:= 0;
						nMoveState 	:= 10;
					END_IF

				10: //Trig state for decision to divert
					IF TrackSectors.afbSector[GC.DIVERTQ_SECTOR_OPART].stSectorStatus.MoverEnteredSector.Q THEN
						GVL_General.stSwitchStatus.ShuttleCountAtDivertTrig		:= GVL_General.stSwitchStatus.ShuttleCountAtDivertTrig +1; //always MODing this; don't need to decrement
						TempItvlMoverIndex	:= ((GVL_General.stSwitchStatus.ShuttleCountAtDivertTrig MOD GVL_General.stSwitchConfig.SwitchModeInternal.IntervalToDivert) +1); // capture the index
					//	AllTrackSectors.M_UpdateSectorCounts(SectorNr := GC.SHORTCUT_CALC_SECTOR_IPART);
						MoverIndexDivertTrig			:= fbPlanarXtsMover.P_MoverId; // regardless of the command to divert, log the MoverID
						DivertQueue.M_UpdateAtTrig();
						nMoveState 	:= 12;
					END_IF
					
				12: // Command to move needs to be given early
					IF TrackSectors.afbSector[GC.DIVERT_DECISION_OPART].stSectorStatus.MoverEnteredSector.Q THEN
						DivertQueue.RemoveObjFromBuffer();
						nMoveState 	:= 13;
					END_IF
				
				13:				
				IF (DivertQueue.P_LastObjectRemoved.MoverID <> 0) THEN // Valid MoverID must be obtained by Remove op in previous step
					IF SwitchMagnet.P_PermIntlkOK AND NOT MagnetControlledByOtherMover AND fbPlanarXtsMover.P_CmdDivert AND 
						(fbPlanarXtsMover.P_XtsPositionInfo.fPartPosition < GVL_Mc3.TrackSectors.P_SectorConfig[GC.MAG_ON_SECTOR_OPART].PartSectorStartPosn)
						AND (stDivertingMover.SysTime <> DivertQueue.P_LastObjectRemoved.SysTime) THEN
							// Divert Move command
							stDivertingMover	:= DivertQueue.P_LastObjectRemoved;
							fbPlanarXtsMover[stDivertingMover.MoverID].P_MC_PlanarMover.MoveOnTrack(commandFeedback := fbPlanarXtsMover[stDivertingMover.MoverID].P_MoverFeedback,
																				targetTrack := GVL_Mc3.MC_Tracks[E_TrackNum.Small],
																				targetPositionOnTrack := (GVL_Mc3.MC_Tracks[E_TrackNum.Small].GetLength() - GC.SHUTTLE_LENGTH) / 2, // midpoint of shortcut
																				constraint := fbPlanarXtsMover[stDivertingMover.MoverID].P_Dynamics,
																				options := fbPlanarXtsMover[stDivertingMover.MoverID].P_MoverOptions.BaseMoveOptions);									
							nMoveState 	:= 30; //Diverting Mover
					ELSIF NOT fbPlanarXtsMover.P_CmdDivert THEN
							nMoveState 	:= 15;
					END_IF
				END_IF
	
				15: // In Recirc - from Main to Big Track
					fbPlanarXtsMover.P_MC_PlanarMover.MoveOnTrack(commandFeedback := fbPlanarXtsMover.P_MoverFeedback,
																		targetTrack := GVL_Mc3.MC_Tracks[E_TrackNum.Big],
																		targetPositionOnTrack := GVL_Mc3.MC_Tracks[E_TrackNum.Big].GetLength()-stTrackGlobalConfig.TargetPosnBeforeTrackEnd,
																		constraint := fbPlanarXtsMover.P_Dynamics,
																		options := fbPlanarXtsMover.P_MoverOptions.BaseMoveOptions);
					 nMoveState 	:= 20;				
					
				20:
					IF TrackSectors.afbSector[GC.OUTER_BIGTRACK_END].stSectorStatus.MoverEnteredSector.Q THEN
						nMoveState     := 5;
					END_IF				

				30: // Match the move command with the shuttle that is commanded to divert
					SwitchMagnet.M_EvaluateInlineCommands();
					
					IF ftMagnetControlledByOtherMover.Q THEN
						nMoveState 	:= 40;
					END_IF
			
				40: // Route through shortcut
					IF TrackSectors.afbSector[GC.LOAD_STOP_SECTOR_IPART].stSectorStatus.MoverEnteredSector.Q THEN
						IF stTrackShortcutConfig.StopAtPowerMat THEN
							nMoveState := 90;
						ELSE
							nMoveState := 50;
						END_IF					
					END_IF
					
				50: //Pre-Merge state
				IF NOT AllTrackSectors.P_AMoverIsOnSector[GC.OUTER_BIGTRACK_LSMALL] 
						(*AND stSwitchConfig.SwitchModeInternal.MaxAllowedDivertCount = GVL_General.nNumMovers*) THEN
					fbPlanarXtsMover.P_eMerge := E_MergeType.FlyingMergeMoveOnTrack;

					fbPlanarXtsMover.P_MC_PlanarMover.MoveOnTrack(commandFeedback := fbPlanarXtsMover.P_MoverFeedback,
																		targetTrack := GVL_Mc3.MC_Tracks[E_TrackNum.Small],
																		targetPositionOnTrack := GVL_Mc3.MC_Tracks[E_TrackNum.Small].GetLength()-stTrackGlobalConfig.TargetPosnBeforeTrackEnd,
																		constraint := fbPlanarXtsMover.P_Dynamics,
																		options := fbPlanarXtsMover.P_MoverOptions.BaseMoveOptions);

					nMoveState := 75;
					//Sync to Master ExpMover
				ELSIF TrackSectors.afbSector[GC.SHORTCUT_MERGE_COMMAND_FLYING].stSectorStatus.MoverEnteredSector.Q THEN
					//Nonzero means there is valid Master Mover data
					IF MergeQueue.P_LastObjectRemoved.MoverID <> 0 THEN
					fbPlanarXtsMover.P_eMerge				:= E_MergeType.FlyingMergeMoveSyncd;
						fbPlanarXtsMover.P_MasterSyncId := MergeQueue.P_LastObjectRemoved.MoverID;
//						IF MergeQueue.P_LastObjectRemoved.ExpMoverType = E_ExpMover.Head THEN
//							fbPlanarXtsMover.P_MasterSyncPosition	:= HeadExpMover[fbPlanarXtsMover.P_MasterSyncId].stExpMoverStatus.TrackSectorCenterHead;
//						ELSIF MergeQueue.P_LastObjectRemoved.ExpMoverType = E_ExpMover.Tail THEN
//							fbPlanarXtsMover.P_MasterSyncPosition	:= TailExpMover[fbPlanarXtsMover.P_MasterSyncId].stExpMoverStatus.TrackSectorCenterTail;
//						END_IF
							// use raw mover reference; likely need some position compensation, i.e, stTrackGlobalConfig.ExpMoverLength;
							fbPlanarXtsMover.P_MasterSyncPosition	:= fbPlanarXtsMover[fbPlanarXtsMover.P_MasterSyncId].P_XtsPositionInfo.fTrackPosition;							
						MergeQueue.ClearLastRemoved(); // master sync data consumed by slave
						nMoveState := 72;					
					END_IF
					
				ELSIF TrackSectors.afbSector[GC.SHORTCUT_MERGE_COMMAND_WAIT].stSectorStatus.MoverEnteredSector.Q OR 
					stTrackShortcutConfig.StopAtPowerMat THEN
					fbPlanarXtsMover.P_eMerge := E_MergeType.MergeFromStaticSyncd;
					
					fbPlanarXtsMover.P_MC_PlanarMover.MoveOnTrack(commandFeedback := fbPlanarXtsMover.P_MoverFeedback,
																		targetTrack := GVL_Mc3.MC_Tracks[E_TrackNum.Small],
																		targetPositionOnTrack := GVL_Mc3.MC_Tracks[E_TrackNum.Small].GetLength()-stTrackGlobalConfig.MergeWaitFinishDistance-stTrackGlobalConfig.MergeWaitAccelDistance,
																		constraint := fbPlanarXtsMover.P_Dynamics,
																		options := fbPlanarXtsMover.P_MoverOptions.BaseMoveOptions);

					nMoveState := 73;
				END_IF

				60: // Merge - Gear In
 //merge with gap zero
					//issue commmand to sync 
//					masterSyncPos := GVL_Mc.MC_Tracks[E_TrackNum.Big].GetLength()-100;
//					masterPosAtSync := Mover[moverInFront].MoverPos; 
//					followSyncPos := GVL_Mc.MC_Tracks[E_TrackNum.Small].GetLength()-1000;
//					followerPosAtSync :=Mover[1].MoverPos; 
//					fbMover[nForCounter].SyncToOtherMover( 
//						masterSyncPos := masterSyncPos,
//						masterTrack := GVL_Mc.MC_Tracks[E_TrackNum.Big],
//						followerSyncPos := followSyncPos,
//						followerTrack := GVL_Mc.MC_Tracks[e_TrackNum.Small],
//						PlanarMoverToFollow := fbMover[moverInFront].P_PlanarMover,
//						velo:= velo);
//						nMoveState := 80; 
//					aggressiveDynamics.SetValuesVADJ(4000,4000,8000,400000); 
//					fbMover[nForCounter].P_Dynamics := aggressiveDynamics;
					//fbMover[nForCounter].MoveOnTrack(GVL_Mc.MC_Tracks[E_TrackNum.Main],  GVL_Mc.MC_Tracks[E_TrackNum.Main].GetLength()-500,900,velo);				
				
//					IF fbPlanarXtsMover.P_eMerge <> E_MergeType.NoMerge THEN
						fbPlanarXtsMover.P_Dynamics.SetValuesVADJ(V := stMoverConfig.NormalVelo, A := stMoverConfig.MaxAccel, D := stMoverConfig.MaxDecel, J := stMoverConfig.MergeJerk);
						
						fbPlanarXtsMover.P_MC_PlanarMover.GearInPosOnTrackWithMasterMover(
								commandFeedback:= fbPlanarXtsMover.P_PlanarFeedbackGearMM, 
								masterMover:= fbPlanarXtsMover[fbPlanarXtsMover.P_MasterSyncId].P_MC_PlanarMover,
								trackTrail:= fbPlanarXtsMover.P_SyncTrail,
								masterSyncPosition:= fbPlanarXtsMover.P_MasterSyncPosition,
								masterSyncPositionTrack:= GVL_Mc3.MC_Tracks[E_TrackNum.Big], 
								slaveSyncPosition:= fbPlanarXtsMover.P_XtsPositionInfo.fTrackPosition,
								slaveSyncPositionTrack:= GVL_Mc3.MC_Tracks[E_TrackNum.Small], 
								constraint:= fbPlanarXtsMover.P_Dynamics, 
								options:= fbPlanarXtsMover.P_MoverOptions.GearInMasterMoverOptions);
								nMoveState := 74;
//					END_IF
						//fbPlanarXtsMover.P_InSync THEN				

				61:
				IF fbPlanarXtsMover.P_MoverFeedback.Done AND ManMergeCmd THEN
					ManMergeCmd	:= FALSE;
					nMoveState := 75; // 62
				END_IF
					
				62:// Permissive to Merge
//					IF NOT AllTrackSectors.P_AMoverIsOnSector[GC.OUTER_MERGE_COLLISION] THEN
//						nMoveState := 63;
//					END_IF

				63://Merge from Inner to Outer
//						fbPlanarXtsMover.P_MC_PlanarMover.MoveOnTrack(commandFeedback := fbPlanarXtsMover.P_MoverFeedback,
//																			targetTrack := GVL_Mc3.MC_Tracks[E_TrackNum.Small],
//																			targetPositionOnTrack := GVL_Mc3.MC_Tracks[E_TrackNum.Small].GetLength()-stTrackGlobalConfig.TargetPosnBeforeTrackEnd,
//																			constraint := fbPlanarXtsMover.P_Dynamics,
//																			options := fbPlanarXtsMover.P_MoverOptions.BaseMoveOptions);
//						nMoveState := 75;
				
				75: //Reset Command On Exit
						IF TrackSectors.afbSector[GC.INNER_MERGE_TO_FINISH].stSectorStatus.MoverEnteredSector.Q THEN
							stSwitchStatus.ShuttleQueueCount := stSwitchStatus.ShuttleQueueCount -1;
							nMoveState := 5;
						END_IF
				
				90: // Stopped at Powermat Station
					IF fbPlanarXtsMover.P_MoverFeedback.Done THEN
						StartTimer[nForCounter] := TRUE;
						nMoveState := 100;
					END_IF
					
				100:
					IF StopTimer[nForCounter].Q THEN
						StartTimer[nForCounter] := FALSE;
						nMoveState := 50;
					END_IF
				END_CASE
				*)]]></ST>
    </Implementation>
    <Folder Name="MoveStateMethods" Id="{90650b54-cbc8-06fd-1fa8-901b23c7e1a4}" />
    <Method Name="M_EvaluateTrackTransition" Id="{1c2ac0b7-8fea-0830-09dd-ae6271fa2e81}" FolderPath="MoveStateMethods\">
      <Declaration><![CDATA[METHOD M_EvaluateTrackTransition
VAR_INPUT
	DepartingTrackRef : OTCID;
	ArrivingTrackRef : OTCID;
	DepartPermissiveSectorRef	: UDINT;
END_VAR
]]></Declaration>
      <Implementation>
        <ST><![CDATA[]]></ST>
      </Implementation>
    </Method>
  </POU>
</TcPlcObject>