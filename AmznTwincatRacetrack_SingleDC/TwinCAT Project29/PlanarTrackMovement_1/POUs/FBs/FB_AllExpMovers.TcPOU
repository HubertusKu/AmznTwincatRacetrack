<?xml version="1.0" encoding="utf-8"?>
<TcPlcObject Version="1.1.0.1">
  <POU Name="FB_AllExpMovers" Id="{e116675b-ae16-0e1f-1a3b-c540b59d6b4a}" SpecialFunc="None">
    <Declaration><![CDATA[FUNCTION_BLOCK FB_AllExpMovers
VAR_INPUT
	HeadMoversRef					: REFERENCE TO ARRAY[GC.nNumMinMovers..GC.nNumMaxMovers] OF FB_ExpandedMover;
	TailMoversRef					: REFERENCE TO ARRAY[GC.nNumMinMovers..GC.nNumMaxMovers] OF FB_ExpandedMover;
	HeadTrackSectorsRef		: REFERENCE TO ARRAY[GC.nNumMinMovers..GC.nNumMaxMovers] OF FB_TrackSectors;
	TailTrackSectorsRef		: REFERENCE TO ARRAY[GC.nNumMinMovers..GC.nNumMaxMovers] OF FB_TrackSectors;		
END_VAR
VAR
	MoverIndex					: UDINT;
	ForCounterExit 			: ARRAY[GC.MIN_SECTOR_CT..GC.MAX_SECTOR_CT] OF UDINT;
	SectorIndex 				: UDINT;
//	LapTrig1						: ST_MergeWindow;
//	LapGap							: ST_MergeWindow;
//	WindowClearDebounce : TIME;
//	GapClearTail				: Tc2_Standard.TON;
	ValidMergeObject		: ST_MoverMerge;
//	AMoverIsOnVoid			:	ARRAY[GC.MIN_SECTOR_CT..GC.MAX_SECTOR_CT] OF BOOL;
END_VAR
VAR CONSTANT
	CONVERT_MS_100NS_COUNT	: LREAL := 1E4;
END_VAR
]]></Declaration>
    <Implementation>
      <ST><![CDATA[_M_Configuration();

_M_EvaluateStatus();]]></ST>
    </Implementation>
    <Method Name="_M_Configuration" Id="{236b3e92-f6bc-03b8-0065-f6a0e2b8201b}">
      <Declaration><![CDATA[METHOD PRIVATE _M_Configuration]]></Declaration>
      <Implementation>
        <ST><![CDATA[FOR MoverIndex := GC.nNumMinMovers TO GC.nNumMaxMovers DO
	HeadMoversRef[MoverIndex].P_ExpMoverConfig := RingBuffer.E_ExpMover.Head;
	TailMoversRef[MoverIndex].P_ExpMoverConfig := RingBuffer.E_ExpMover.Tail;
END_FOR]]></ST>
      </Implementation>
    </Method>
    <Method Name="_M_EvaluateStatus" Id="{19b0e65e-a05f-096f-265a-b0e2b7cf8b15}">
      <Declaration><![CDATA[METHOD PRIVATE _M_EvaluateStatus]]></Declaration>
      <Implementation>
        <ST><![CDATA[FOR MoverIndex := GC.nNumMinMovers TO GC.nNumMaxMovers DO
	IF HeadTrackSectorsRef[MoverIndex].SectorStatus[GC.OUTER_SHORTCUT_PROJECTION].MoverEnteredSector.Q THEN
		//
	ELSIF TailTrackSectorsRef[MoverIndex].SectorStatus[GC.OUTER_SHORTCUT_PROJECTION].MoverExitedSector.Q THEN
		//
	END_IF
END_FOR]]></ST>
      </Implementation>
    </Method>
    <Method Name="_M_EvaluateStatus1" Id="{44e0cc83-293d-0d9c-2381-994debd354e2}">
      <Declaration><![CDATA[METHOD PRIVATE _M_EvaluateStatus1]]></Declaration>
      <Implementation>
        <ST><![CDATA[IF ADR(TrackSectorsRef) <> 0 THEN // pointer validity check
	FOR MoverIndex := GC.nNumMinMovers TO GVL_General.nNumMovers BY 1 DO
		FOR SectorIndex := GC.MIN_SECTOR_CT TO GC.MAX_SECTOR_CT BY 1 DO
			
//			IF LapTrig1.Latch AND_THEN TrackSectorsRef[MoverIndex].SectorStatus[GC.OUTER_FINISH_MOVERTOFOLLOW].MoverIsOnSector THEN
//				MoverIdToFollowOnMerge	:= MoverIndex;
//			END_IF
	
		END_FOR
	END_FOR
END_IF

//Merge Combined
//FOR ForCounterExit[GC.OUTER_MERGE_INFRONT] := GC.nNumMinMovers TO GVL_General.nNumMovers BY 1 DO
//	IF AllSectorStatus[ForCounterExit[GC.OUTER_MERGE_INFRONT]][GC.OUTER_MERGE_INFRONT].MoverIsOnSector THEN
//			AMoverIsOnSector[GC.OUTER_MERGE_INFRONT] := TRUE;
//			EXIT;
//		ELSIF NOT AllSectorStatus[ForCounterExit[GC.OUTER_MERGE_INFRONT]][GC.OUTER_MERGE_INFRONT].MoverIsOnSector THEN
//			AMoverIsOnSector[GC.OUTER_MERGE_INFRONT] := FALSE;
//		END_IF
//END_FOR

//Lap Trig 1
FOR ForCounterExit[GC.OUTER_FINISH_LAPTRIG] := GC.nNumMinMovers TO GVL_General.nNumMovers BY 1 DO
//		IF AllSectorStatus[ForCounterExit[GC.OUTER_FINISH_LAPTRIG1]][GC.OUTER_FINISH_LAPTRIG1].MoverIsOnSector THEN
//			AMoverIsOnSector[GC.OUTER_FINISH_LAPTRIG1] := TRUE;
//			EXIT;
//		ELSIF NOT AllSectorStatus[ForCounterExit[GC.OUTER_FINISH_LAPTRIG1]][GC.OUTER_FINISH_LAPTRIG1].MoverIsOnSector THEN
//			AMoverIsOnSector[GC.OUTER_FINISH_LAPTRIG1] := FALSE;
//		END_IF
	IF NOT LapTrig1.Latch AND NOT LapGap.Latch AND AllSectorStatus[ForCounterExit[GC.OUTER_FINISH_LAPTRIG]][GC.OUTER_FINISH_LAPTRIG].MoverExitedSector.Q THEN
			LapTrig1.Latch := TRUE;
			GapClearTail.IN	:= TRUE;
			LapTrig1.timestamp	:= Tc2_System.F_GetSystemTime();
			EXIT;
		END_IF
	IF LapTrig1.Latch AND NOT LapGap.Latch AND AllSectorStatus[ForCounterExit[GC.OUTER_FINISH_LAPTRIG]][GC.OUTER_FINISH_LAPTRIG].MoverEnteredSector.Q THEN
			LapGap.Latch := TRUE;
			LapGap.timestamp	:= Tc2_System.F_GetSystemTime();
			EXIT;
		END_IF
		
END_FOR

//Lap Trig 2
//FOR ForCounterExit[GC.OUTER_FINISH_LAPTRIG2] := GC.nNumMinMovers TO GVL_General.nNumMovers BY 1 DO
//		IF AllSectorStatus[ForCounterExit[GC.OUTER_FINISH_LAPTRIG2]][GC.OUTER_FINISH_LAPTRIG2].MoverIsOnSector THEN
//			AMoverIsOnSector[GC.OUTER_FINISH_LAPTRIG2] := TRUE;
//			EXIT;
//		ELSIF NOT AllSectorStatus[ForCounterExit[GC.OUTER_FINISH_LAPTRIG2]][GC.OUTER_FINISH_LAPTRIG2].MoverIsOnSector THEN
//			AMoverIsOnSector[GC.OUTER_FINISH_LAPTRIG2] := FALSE;
//		END_IF
//	IF LapTrig1.Latch AND NOT LapTrig2.Latch AND_THEN AllSectorStatus[ForCounterExit[GC.OUTER_FINISH_LAPTRIG2]][GC.OUTER_FINISH_LAPTRIG2].MoverEnteredSector.Q THEN
//			LapTrig2.Latch := TRUE;
//			EXIT;
//		END_IF
//END_FOR

_M_EvaluateWindow();

GapClearTail(PT := WindowClearDebounce);]]></ST>
      </Implementation>
    </Method>
    <Method Name="_M_EvaluateWindow" Id="{70d44e2b-75f6-0653-032e-9e64a1433a4c}">
      <Declaration><![CDATA[METHOD PRIVATE _M_EvaluateWindow
VAR_INST
	TrigAdd : BOOL;
	TrigRem : BOOL;
	DistanceDeltaFromMerge : LREAL;
	TempCalc : LREAL;
END_VAR
]]></Declaration>
      <Implementation>
        <ST><![CDATA[IF (stMoverConfig.NormalVelo - stMoverConfig.VeloComp) <> 0 THEN
	WindowClearDebounce := LREAL_TO_TIME(1000*stTrackGlobalConfig.ExpMoverLength / (stMoverConfig.NormalVelo - stMoverConfig.VeloComp));
END_IF

IF LapTrig1.Latch AND LapGap.Latch THEN
//	TimeDeltaTemp	:= LapGap.timestamp - LapTrig1.timestamp;
//	TimeDelta := ULINT_TO_REAL(TimeDeltaTemp) / TicksPerS;

	LapTrig1.Latch := FALSE;
	LapGap.Latch := FALSE;
	GapClearTail.IN	:= FALSE;

END_IF

IF GapClearTail.Q AND NOT LapGap.Latch THEN
	// Position to match with merging mover
	LapTrig1.timestamp;
//	MergeQueue.AddObjToBuffer(RefObject := );
	GapClearTail.IN	:= FALSE;
END_IF

//DistanceDeltaFromMerge := GVL_Mc3.MC_Tracks[E_TrackNum.Big].GetLength() - ValidPosnTime.ValidPosnSrc;
IF (stMoverConfig.NormalVelo - stMoverConfig.VeloComp) <> 0 THEN 
	TempCalc 	:= 1000* (DistanceDeltaFromMerge / (stMoverConfig.NormalVelo - stMoverConfig.VeloComp));
END_IF
//TargetTimeForLastTPosnAtMerge	:= MergeQueue.P_LastObjectRemoved + LREAL_TO_ULINT(TempCalc * CONVERT_MS_100NS_COUNT);  //ms to count of 100ns intervals

//ValidPosnTime.ValidTargetDestTime := MergeQueue.P_LastObjectRemoved + ;

IF TrigRem THEN
	TrigRem	:= FALSE;
	MergeQueue.RemoveObjFromBuffer();
END_IF

IF TrigAdd THEN
	TrigAdd	:= FALSE;
	MergeQueue.AddObjToBuffer(RefObject := ValidMergeObject);	
END_IF

//Make a dynamic sector that follows the "virtual" position; could be used as a PermIntlk for violation of the sector by a real mover;]]></ST>
      </Implementation>
    </Method>
  </POU>
</TcPlcObject>